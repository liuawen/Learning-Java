<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="49h3dmkalf1lbsn2ate9jopuba" modified-by="" style-id="487gi5ovjek2lvp9sjqneegdtc" theme="xminddefaultthemeid" timestamp="1511919219270" xmlns="urn:xmind:xmap:xmlns:content:2.0"><topic id="17mrtu3l8chvr316vtlolrv07t" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1511917490164"><title>面向对象高级特性</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="1paeq8kqq69qcoreld5icu5r7e" modified-by="" timestamp="1511746221190"><title>抽象</title><children><topics type="attached"><topic id="26lq6ojq91drvctqd194cmlj19" modified-by="" timestamp="1511746062378"><title>为什么会有抽象类</title><children><topics type="attached"><topic id="3flq27ks2u6m029ei8m064pjf1" modified-by="" timestamp="1511746060709"><title svg:width="500">当子类中都有一个共同的方法，每一个子类都有不同的实现，在父类中又要体现所有子类的共同的特点，所以要体现有这个方法，但是在父类中又无法给出具体的实现，那么这个时候就需要把这个方法声明为抽象的，而包含抽象方法的类，必须是抽象类</title></topic><topic id="56fh3u1p97qapvi46m1dek242b" modified-by="" timestamp="1511746062367"><title svg:width="500">某个父类仅仅是表示一个抽象的概念，不希望它被实例化，这个时候父类中可能没有抽象方法，但是我们也把它声明为抽象类</title></topic></topics></children></topic><topic id="123ijf5ufk02e9tkmv621643i8" modified-by="" timestamp="1511746077195"><title>如何声明抽象类</title><children><topics type="attached"><topic id="4nte0l0akjtd9l457l1gdoi2q1" modified-by="" timestamp="1511746081151"><title>语法格式</title><children><topics type="attached"><topic id="78sclc0ffelqj69gv8luujj2bl" modified-by="" timestamp="1511746082334"><title>[public/缺省] abstract class 类名{&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="2s6ln2a41ik1mi005guu7p765b" modified-by="" timestamp="1511746096316"><title>如何声明抽象方法</title><children><topics type="attached"><topic id="7tinf1bmpm2jn2micln2jve6tt" modified-by="" timestamp="1511746101722"><title>语法格式</title><children><topics type="attached"><topic id="2mumclp913nt2ejnmknedj5mep" modified-by="" timestamp="1511746171478"><title svg:width="500">[public/protected/缺省]  abstract   返回值类型   方法名([形参列表]);</title><children><topics type="attached"><topic id="3u5381ju238ve24u8h89c2n34p" modified-by="" timestamp="1511746185994"><title>抽象方法是不能private,static,final修饰的</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0d1jfqfrqcsnua5k2kngt17uvc" modified-by="" timestamp="1511746211072"><title>抽象类的特点</title><children><topics type="attached"><topic id="7ci60vi3d439aabh6la3bh5apt" modified-by="" timestamp="1511746212456"><title svg:width="500">（1）抽象类不能实例化&#13;
（2）抽象类可以包含抽象方法，也可以没有抽象方法。&#13;
如果一个类有抽象方法，那么这个类必须是抽象类，&#13;
如果一个抽象类没有抽象方法，那么它的用意是不想实例化，用它仅仅表示一个抽象的概念。&#13;
（3）抽象类生来就是用来被继承的，那么子类在继承它的时候，必须重写（实现）抽象父类的抽象方法，&#13;
否则该子类也得是抽象类。&#13;
（4）抽象类的变量与子类的对象构成多态引用。&#13;
（5）抽象类除了不能实例化，可以包含抽象方法，其他的和非抽象类是一样的，&#13;
可以有成员变量（类变量、实例变量）、构造器、代码块（静态代码块和非静态代码块）&#13;
方法（静态方法、非静态方法）</title></topic></topics></children></topic><topic id="2ff3r3hk6t1gva75bht27r6p31" modified-by="" timestamp="1511746228241"><title>抽象类不能实例化，为什么要有构造器呢？</title><children><topics type="attached"><topic id="7hljroh7pr5a9an2qtk8iks6jd" modified-by="" timestamp="1511746233915"><title svg:width="500">子类在继承该类时，一定要调用它的构造器，为属性初始化。</title><children><topics type="attached"><topic id="3dp2qh9n1p52f49hpvfbkjous8" modified-by="" timestamp="1511746262782"><title>因为构造器的作用有两点</title><children><topics type="attached"><topic id="01ujrfombs96jta9iln15lunna" modified-by="" timestamp="1511746262111"><title>（1）和new一起创建对象</title></topic><topic id="4kssbig2sem414f7i5bmoc464c" modified-by="" timestamp="1511746274933"><title>（2）为属性初始化</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="689idmgjbepi4ep6e5c9ktn66i" modified-by="" timestamp="1511747076644"><title>接口</title><children><topics type="attached"><topic id="5ucmhu24dj50qkppneuq5g68o9" modified-by="" timestamp="1511746785541"><title>接口即代表行为标准，功能标准</title></topic><topic id="4da2cknbt8vhqhjhfp1g7q2t2u" modified-by="" timestamp="1511746986735"><title>如何声明一个接口？</title><children><topics type="attached"><topic id="4tgoe6vuqilq7bo70n04hmjt79" modified-by="" timestamp="1511746992062"><title>语法结构</title><children><topics type="attached"><topic id="5igv1qs304u3fcf2e8857m5hkq" modified-by="" timestamp="1511746993186"><title>[public/缺省] interface 接口名{&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="12mht89p2484t7apl6pkckl5v4" modified-by="" timestamp="1511747006749"><title>如何实现接口？</title><children><topics type="attached"><topic id="4nrn13nokgabbgvkpg4adfullg" modified-by="" timestamp="1511747023551"><title>语法结构</title><children><topics type="attached"><topic id="0jk10oauuk4he90o7uip7875l3" modified-by="" timestamp="1511747024980"><title svg:width="500">[public/缺省] class 子类名 [extends 父类名] implements  接口名1，接口名2。。。{&#13;
	//要实现接口的所有抽象方法&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="5o8cp338iokj94q9feebr93e9i" modified-by="" timestamp="1511747134822"><title>接口的特点</title><children><topics type="attached"><topic id="24eln82jcppeijs8aaqj8jo9sa" modified-by="" timestamp="1511747112136"><title>JDK1.7</title><children><topics type="attached"><topic id="30php8rsf5hlg8oj2f6ccckk16" modified-by="" timestamp="1511747114072"><title svg:width="500">JDK1.7：&#13;
（1）接口不能实例化&#13;
（2）接口只能有全局静态的常量和公共的抽象方法&#13;
（3）接口中不能有构造器，因为它没有属性需要初始化，又不能创建对象&#13;
（4）接口生来用来被实现的，那么实现类（像子类）在实现它时，必须实现（和重写要求一样）接口的&#13;
所有抽象方法，否则该实现类也得是抽象类&#13;
（5）一个类可以同时实现多个接口&#13;
（6）一个类还可以继承父类又实现接口，但是必须先继承后实现&#13;
（7）接口与接口之间是继承关系，一个接口可以继承多个接口&#13;
（8）接口与实现类的对象之间构成多态引用</title></topic></topics></children></topic><topic id="6611cktbpm1cpgjskjvlmbt3o7" modified-by="" timestamp="1511747145811"><title>JDK1.8</title><children><topics type="attached"><topic id="6sisbmqcmhc2k58v0ie07tqob2" modified-by="" timestamp="1511747209402"><title svg:width="500">其他的和JDK1.7一样，不一样的是：&#13;
JDK1.8之后，接口中除了全局静态的常量和公共的抽象方法以外，可以有静态方法和默认方法</title><children><topics type="attached"><topic id="3tqv5qo96euci3f05qttp6pc7g" modified-by="" timestamp="1511747196151"><title>接口中的静态方法</title><children><topics type="attached"><topic id="7v80fhtoo1rb64v28t0c6b0riv" modified-by="" timestamp="1511747194942"><title svg:width="500">当接口的所有实现类，对这个方法的实现是一样的，这个方法就设计在接口中，设计为静态方法</title></topic><topic id="3ho2il8t1s3hlf5309dtmanhf1" modified-by="" timestamp="1511747200572"><title>如何调用</title><children><topics type="attached"><topic id="14ngpp1dokp2r4o9st528o5k07" modified-by="" timestamp="1511747205688"><title>接口名.方法</title></topic></topics></children></topic></topics></children></topic><topic id="3ci070vn5iertsm1k055sgmjk3" modified-by="" timestamp="1511747466454"><title>接口中的默认方法</title><children><topics type="attached"><topic id="57gf1e45aea59rqadcd3rm9ofd" modified-by="" timestamp="1511747261595"><title svg:width="500">当接口的大多数实现类，对这个方法的实现是一样，那么这个方法的实现就可以在接口中提供默认实现，如果某个实现类觉得他不合适，只需要重写它即可</title></topic><topic id="3ueqak93ahucgjdkmqs74qdh33" modified-by="" timestamp="1511747302860"><title>如何调用</title><children><topics type="attached"><topic id="3qh3souakitd10m8g054ht1m7h" modified-by="" timestamp="1511747302037"><title>实现类外</title><children><topics type="attached"><topic id="3aqguqh5qs2mcjcl3id7kvsrd8" modified-by="" timestamp="1511747302018"><title>实现类对象.方法</title></topic></topics></children></topic><topic id="3mav7dkjk2k3ageo2d7dg12v8b" modified-by="" timestamp="1511747329806"><title>实现类中</title><children><topics type="attached"><topic id="68lh8jqu05h48l9cqh772c67hm" modified-by="" timestamp="1511747328308"><title svg:width="500">如果实现类要重写该默认方法，但是又想调用接口中的默认实现</title></topic><topic id="2fihn3q16ealhkj9c90nmnipo7" modified-by="" timestamp="1511747339312"><title>接口名.super.方法</title></topic></topics></children></topic></topics></children></topic><topic id="1pfec4j3q62g3lel02u0koqlag" modified-by="" timestamp="1511747376830"><title>什么情况下需要重写</title><children><topics type="attached"><topic id="13ojndejcqqdddbgju9d6jrnbn" modified-by="" timestamp="1511747373525"><title>接口中的默认实现不适合该实现类</title></topic><topic id="4m95lf2fevuv6ib1tr1c80gaq7" modified-by="" timestamp="1511747383155"><title>必须重写</title><children><topics type="attached"><topic id="6l0g11t7hfb47h9mjqd2aq3op6" modified-by="" timestamp="1511747454317"><title svg:width="500">一个类同时实现了多个接口，而多个接口中都相同的默认方法（方法名和形参列表都相同），这个时候实现类必须做出选择，要重写，如果需要保留其中一个的话，通过接口名.super.方法，保留它的默认实现</title></topic></topics></children></topic></topics></children></topic><topic id="6lrim758b6mrpod9uo3t4m44jj" modified-by="" timestamp="1511747475302"><title>类优先原则</title><children><topics type="attached"><topic id="4cs419onrk99p5519s53njqc7l" modified-by="" timestamp="1511747524680"><title svg:width="500">当一个类继承了父类，又实现了接口，而且父类中的某个方法与接口中的默认方法一样（方法名和形参列表），默认保留的是父类中的方法实现</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7ia5a5520b8e8d8ei531imdsac" modified-by="" timestamp="1511832345324"><title>枚举</title><children><topics type="attached"><topic id="1j0vdmir49eefkm55jcufsklvg" modified-by="" timestamp="1511832334881"><title svg:width="500">枚举是指某个类型的对象是有限个，在类型中一一创建并列举它的对象</title></topic><topic id="65t48r4dd5sndlsfam6rkp9j0u" modified-by="" timestamp="1511832383251"><title>JDK1.5之前，如何解决</title><children><topics type="attached"><topic id="3omaj95f2kgf76kof7qje1fave" modified-by="" timestamp="1511832369927"><title>（1）构造器私有化</title></topic><topic id="16v4k852661sm5j02hmji73qpo" modified-by="" timestamp="1511832381966"><title>（2）通过常量的方式创建好所有对象</title></topic><topic id="48domp1vd060almp5nb2ggfu8b" modified-by="" timestamp="1511832417126"><title>示例</title><notes><html><xhtml:p>class Week{</xhtml:p><xhtml:p>	public static final Week MONDAY = new Week();</xhtml:p><xhtml:p>	public static final Week TUESDAY = new Week();</xhtml:p><xhtml:p>	public static final Week WEDNESDAY = new Week();</xhtml:p><xhtml:p>	public static final Week THURSDAY = new Week();</xhtml:p><xhtml:p>	public static final Week FRIDAY = new Week();</xhtml:p><xhtml:p>	public static final Week SATURDAY = new Week();</xhtml:p><xhtml:p>	public static final Week SUNDAY = new Week();</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	private Week(){</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>Week w = Week.MONDAY;</xhtml:p></html><plain>class Week{&#13;
	public static final Week MONDAY = new Week();&#13;
	public static final Week TUESDAY = new Week();&#13;
	public static final Week WEDNESDAY = new Week();&#13;
	public static final Week THURSDAY = new Week();&#13;
	public static final Week FRIDAY = new Week();&#13;
	public static final Week SATURDAY = new Week();&#13;
	public static final Week SUNDAY = new Week();&#13;
	&#13;
	private Week(){&#13;
		&#13;
	}&#13;
}&#13;
&#13;
&#13;
Week w = Week.MONDAY;</plain></notes></topic></topics></children></topic><topic id="0mtbis72dor198m903rlr8hbtr" modified-by="" timestamp="1511832491652"><title>JDK1.5之后，如何解决</title><children><topics type="attached"><topic id="5lpd8tddk3fr03qot6rr1tur1t" modified-by="" timestamp="1511832486061"><title>如何声明</title><children><topics type="attached"><topic id="1qokinkjcg5v0vkvqmokm4mhnv" modified-by="" timestamp="1511832472742"><title>[修饰符] enum  枚举类型名{&#13;
	常量对象列表&#13;
}</title></topic><topic id="0pspajk423pg160pqcef1ss3g1" modified-by="" timestamp="1511832487609"><title>[修饰符] enum  枚举类型名{&#13;
	常量对象列表;&#13;
	其他成员;&#13;
}</title></topic></topics></children></topic><topic id="0kitt3dt52hi3v44gcpa45cslj" modified-by="" timestamp="1511832830624"><title>特点</title><children><topics type="attached"><topic id="1aqosu7ifs8d5h0dko7bkgbfqj" modified-by="" timestamp="1511832519457"><title>（1）枚举类型中的构造器都是私有化</title></topic><topic id="32c97albste0k5bmcot59ji8fo" modified-by="" timestamp="1511832546476"><title svg:width="500">（2）常量对象列表必须在首行，如果常量对象列表后面还有其他的代码，那么要用;结束</title></topic><topic id="66bvntbi20d3e41i65j85or9dl" modified-by="" timestamp="1511832762090"><title svg:width="500">（3）枚举类型不能继承别的类型，因为它默认继承java.lang.Enum</title><children><topics type="attached"><topic id="5imsvrabh4u58hbdenskuvqksv" modified-by="" timestamp="1511832741911"><title>它有一些方法</title><children><topics type="attached"><topic id="2en4e889vp49l0adodbpan6l4n" modified-by="" timestamp="1511832610160"><title>name()</title><children><topics type="attached"><topic id="2onobn15p3d90oo1jvuq6l8fgp" modified-by="" timestamp="1511832619099"><title>返回常量对象名</title></topic></topics></children></topic><topic id="16r3fftdfs7b6hk72hpf3ebebs" modified-by="" timestamp="1511832624528"><title>ordinal()</title><children><topics type="attached"><topic id="7bp0a4o08dlbuvb54472dphcvq" modified-by="" timestamp="1511832636602"><title>返回常量对象的序号，从0开始</title></topic></topics></children></topic><topic id="1opncbqtbhv7blr0g8imppbjkq" modified-by="" timestamp="1511832670253"><title svg:width="500">实现了java.lang.Comparable接口，重写compareTo()，按照常量对象的顺序排序</title><children><topics type="attached"><topic id="66v5169umvf91v01n665bhhhab" modified-by="" timestamp="1511832684812"><title>如果自己的枚举类中不适合，可以重写</title></topic></topics></children></topic><topic id="3i64hb27fv50q4upi66h26uemd" modified-by="" timestamp="1511832748662"><title>toString()</title><children><topics type="attached"><topic id="4i6iadg1m3007utrc9b05aeehg" modified-by="" timestamp="1511832750046"><title>返回常量对象名</title><children><topics type="attached"><topic id="07i5bubda8p6nnil79ngvlke4t" modified-by="" timestamp="1511832752852"><title>可以重写</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7chqneahq8uauc9nfghf89adrg" modified-by="" timestamp="1511832793557"><title>API中没有的方法</title><children><topics type="attached"><topic id="7gk0ondc2g2slp3vmjtnrhvbt3" modified-by="" timestamp="1511832783117"><title>枚举类型名.values()</title><children><topics type="attached"><topic branch="folded" id="2ionc3k8atllnajog1noa4kdce" modified-by="" timestamp="1511832792630"><title>返回枚举常量对象组成的数组</title></topic></topics></children></topic><topic id="2u9acbec8p04ovubkv0g2v5spg" modified-by="" timestamp="1511832811881"><title>枚举类型名.valueOf（常量对象的名称）</title><children><topics type="attached"><topic id="1mqtj04mdkb2ahagmna2tc8im0" modified-by="" timestamp="1511832822714"><title>返回某一个指定的对象</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6lnia719nojagpv5imdg3pdeha" modified-by="" timestamp="1511832907003"><title>（4）switch对枚举加入支持</title><children><topics type="attached"><topic id="2hqdc4jacooj2mab1ms6ue3388" modified-by="" timestamp="1511832908346"><title>switch(枚举类型表达式){&#13;
	case 常量对象名1:&#13;
		语句;&#13;
		[break;]&#13;
	case 常量对象名2:&#13;
		语句;&#13;
		[break;]&#13;
	case 常量对象名3:&#13;
		语句;&#13;
		[break;]	&#13;
	default:&#13;
		语句;&#13;
		[break;]		&#13;
}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="65i9jlphpqp40p1ro47gbtp0go" modified-by="" timestamp="1511918862221"><title>注解</title><children><topics type="attached"><topic id="3ci3p3ba2tu4ujtk7cporv7k39" modified-by="" timestamp="1511917536068"><title>概念</title><children><topics type="attached"><topic id="2saf0do1vc9kvuli43lvk8mkng" modified-by="" timestamp="1511917533462"><title>代码级别的注释</title></topic><topic id="7etj8kf7rl7c2vbv04jdq5catr" modified-by="" timestamp="1511917542666"><title>给代码读取的注释</title><children><topics type="attached"><topic id="3s4vi33qdr3fa8enhs23lfe2f6" modified-by="" timestamp="1511917567576"><title>不同普通的注释（给人看的）</title><children><topics type="attached"><topic id="7vdt2bltk42qatbqjqgk8cnuk6" modified-by="" timestamp="1511917554139"><title>单行注释</title></topic><topic id="7p6nc7ivi7ii4adpmriubjpsa4" modified-by="" timestamp="1511917558136"><title>多行注释</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="4lslfhoe04lu2h5no2ke83c3il" modified-by="" timestamp="1511917616934"><title>四种</title><children><topics type="attached"><topic id="0bs3m24qv0oproosliigfku7ei" modified-by="" timestamp="1511919202075"><title>1、编译器的格式检查</title><children><topics type="attached"><topic id="5atm2m0o21moqf3r9rkbi1em8t" modified-by="" timestamp="1511917656968"><title svg:width="500">（1）@Override：告知编译器对该方法按照“重写”的要求进行格式检查</title></topic><topic id="2f7pg4hqagf5h5udb79enu8fo3" modified-by="" timestamp="1511917686705"><title svg:width="500">（2）@SuppressWarnings：告知编译器抑制警告</title></topic><topic id="1vr69h1kure7bn1h7vluph4gj2" modified-by="" timestamp="1511917700125"><title svg:width="500">（3）@Deprecated：告知编译器某个元素是已过时，有人用了就弹出警告</title></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="6f57ejkqgbmd6g9it98vhdv9iu" modified-by="" timestamp="1511918051824"><title>2、文档注释</title><children><topics type="attached"><topic id="1npi2c3g2610keg3hei80bhhg5" modified-by="" timestamp="1511917791112"><title>（1）@version</title><children><topics type="attached"><topic id="5dr9hsa4o35lrq9sgtg1dg8ic3" modified-by="" timestamp="1511917796851"><title>指定当前版本</title></topic></topics></children></topic><topic id="64nagkslt62go4gch4h5553n0l" modified-by="" timestamp="1511917797087"><title>（2）@author</title><children><topics type="attached"><topic id="6fuggojblgoam6nc91ini9ft1u" modified-by="" timestamp="1511917800644"><title>指定作者</title></topic></topics></children></topic><topic id="19864n0m5iq9mkuregakgjqhh4" modified-by="" timestamp="1511917801049"><title>（3）@since</title><children><topics type="attached"><topic id="74de6ovi6oshvfbpcnh5qkf11q" modified-by="" timestamp="1511917808102"><title>指定从哪个版本开始</title></topic></topics></children></topic><topic id="4545kfps2ln6jc62u1kdi3c2j4" modified-by="" timestamp="1511917808425"><title>（4）@see</title><children><topics type="attached"><topic id="7hbu5djecok1c96ren9b5i2llp" modified-by="" timestamp="1511917814251"><title>另请参阅</title></topic></topics></children></topic><topic id="1ljsl24jbhpap71ijk1rro2dmi" modified-by="" timestamp="1511917922163"><title>（5）param</title><children><topics type="attached"><topic id="7oa0gahq60g1tbqiahd672kjfe" modified-by="" timestamp="1511917830486"><title>指定当前方法的形参信息</title></topic><topic id="42bri3p998b025ivilai6v433p" modified-by="" timestamp="1511917857409"><title>可以多个</title></topic><topic id="5hnf0cavqakgo74tnkfacf0orm" modified-by="" timestamp="1511917899057"><title>只有方法有形参才能标记</title></topic><topic id="1qi4jqj8kf8ns7j20dgas8ngdn" modified-by="" timestamp="1511917927034"><title>格式：</title><children><topics type="attached"><topic id="5g7k8t7ppc1vjodclodleao8bq" modified-by="" timestamp="1511917961297"><title>@param  形参名  形参类型   形参的描述信息</title></topic></topics></children></topic></topics></children></topic><topic id="3mljegutd04ijn3trubmps7s7s" modified-by="" timestamp="1511917963103"><title>（6）@return</title><children><topics type="attached"><topic id="2mvg834o7gs6j14lknpk575p2q" modified-by="" timestamp="1511917838308"><title>指定当前方法的返回值信息</title></topic><topic id="2sbcu5u7nlpridqimljroi7v0j" modified-by="" timestamp="1511917887758"><title svg:width="500">一个方法只能有一个，如果方法是void，就不能标记@return</title></topic><topic id="4ki6f56fn8bmjbrbllifhc5jk5" modified-by="" timestamp="1511917966966"><title>格式</title><children><topics type="attached"><topic id="3f9csf3hgesidiiv0hk2i3op9m" modified-by="" timestamp="1511917984388"><title>@return  返回值的类型  返回值的描述</title></topic></topics></children></topic></topics></children></topic><topic id="2fpp1eukort9tarkkm2afasq62" modified-by="" timestamp="1511917988178"><title>（7）@exception</title><children><topics type="attached"><topic id="3c5gqjh72l6h9prmg9c0in8bvk" modified-by="" timestamp="1511917850249"><title>指定当前方法抛出异常的信息</title></topic><topic id="77cab2enhifs4vcnbvugobss5n" modified-by="" timestamp="1511917860645"><title>可以多个</title></topic><topic id="5g63q46tca2aepg3bp0g4k17nh" modified-by="" timestamp="1511917910812"><title>只有方法抛出异常才能标记</title></topic><topic id="6a7bnu3j0rn43pd5knig9r9e8a" modified-by="" timestamp="1511917988145"><title>格式</title><children><topics type="attached"><topic id="7lkdrfngdj76g1jjr04a8jrnn1" modified-by="" timestamp="1511918008220"><title>@exception  异常类型  异常的描述</title></topic></topics></children></topic></topics></children></topic><topic id="4vqk1c77jnev9ef4ued454rqr1" modified-by="" timestamp="1511918060800"><title>结合javadoc.exe</title></topic></topics></children></topic><topic id="6q6s426jtc27i46e1l2ea05edm" modified-by="" timestamp="1511918170782"><title>3、JUnit的单元测试</title><children><topics type="attached"><topic id="3irhnqm8idhqjasecu4ckpjhth" modified-by="" timestamp="1511918113242"><title svg:width="500">白盒测试，程序员自己的测试，在程序员知道当前的代码的功能的</title></topic><topic id="3mmd3c6oc5qa2volnsotgpskk4" modified-by="" timestamp="1511919207034"><title>@Test</title><children><topics type="attached"><topic id="1i0phft813c04gbi15ofgfa709" modified-by="" timestamp="1511918126217"><title>加在方法上</title></topic><topic id="2e4gplntc5cq4lgdae1qnomk0c" modified-by="" timestamp="1511918145033"><title svg:width="500">这个方法必须是公共的，无参，无返回值，不能是static</title></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="1d5scs7ti5lej0jfdtmhbs101f" modified-by="" timestamp="1511918155978"><title>@Before</title><children><topics type="attached"><topic id="4opu33d3v7v6hfjmn0qne6bj9b" modified-by="" timestamp="1511918168416"><title>在@Test标记的方法之前运行</title></topic></topics></children></topic><topic id="3smfq1empd0hspipcfulbic0ro" modified-by="" timestamp="1511918176460"><title>@After</title><children><topics type="attached"><topic id="05qji2jnm6jf4vru8bd74vb1ul" modified-by="" timestamp="1511918182001"><title>在@Test标记的方法之后运行</title></topic></topics></children></topic></topics></children></topic><topic id="64m91btiaethhdkn4b6bt0pqvj" modified-by="" timestamp="1511917634028"><title>4、各大框架等替代配置文件</title></topic></topics></children></topic><topic id="1fo7vqknsmah8gl96tfb5semv8" modified-by="" timestamp="1511918278865"><title>注解的三个部分</title><children><topics type="attached"><topic id="31nakhmje8tvuadp2h0d9bpfd9" modified-by="" timestamp="1511918258186"><title>1、声明</title><children><topics type="attached"><topic id="444gjo0447sg4abdfkb1kr2tcd" modified-by="" timestamp="1511918268705"><title>一般都是别人声明好的</title></topic></topics></children></topic><topic id="766umok5etsjm4jh5inljsba93" modified-by="" timestamp="1511918277696"><title>2、使用</title></topic><topic id="3150qnca940prgok46nhi4gjd0" modified-by="" timestamp="1511918394462"><title>3、读取</title><children><topics type="attached"><topic id="5r5eboo2sm634ppcactrkd023h" modified-by="" timestamp="1511918314205"><title>例如：@Override等，由javac.exe</title></topic><topic id="2g0biqkeuijosidjlub7imegkc" modified-by="" timestamp="1511918337187"><title>例如：@author,@param等，由javadoc.exe</title></topic><topic id="7esl8lo63ddsddfuj6e7jvvpti" modified-by="" timestamp="1511918362839"><title>例如：@Test等，由JUnit相关的类读取</title></topic><topic id="7v09oc0aesqvgpu50jku4qm3cq" modified-by="" timestamp="1511918385809"><title>例如：@WebServlet等，由Tomcat读取</title></topic><topic id="7drtkj7eijl5ijfk79nol4f55c" modified-by="" timestamp="1511918390680"><title>...</title></topic><topic id="61apg0har9pnv6b1hmr7goi94n" modified-by="" timestamp="1511918442474"><title svg:width="500">如果自己要读取，通过反射，而且只能读取@Retention(RetentionPolicy.RUNTIME)</title><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic></topics></children></topic></topics></children></topic><topic id="0car5k1iu5ml4io29buvo3t5na" modified-by="" timestamp="1511918461504"><title>注解的声明</title><children><topics type="attached"><topic id="07hfq956fige8n3hftq8f77o62" modified-by="" timestamp="1511918498667"><title>（1）无参</title><children><topics type="attached"><topic id="68d2gkvf4t01rlrsftri7ifkvd" modified-by="" timestamp="1511918497771"><title>声明格式</title><children><topics type="attached"><topic id="3mbag8sda6s4blj863mdgcl9bk" modified-by="" timestamp="1511918497745"><title>@元注解&#13;
[修饰符]  @interface  注解名{}</title></topic></topics></children></topic><topic id="2pno6qri1qi0ho3e0dhblkp9bc" modified-by="" timestamp="1511918503636"><title>使用格式</title><children><topics type="attached"><topic id="5jqjgbjqd54ll1nje7vidb21ri" modified-by="" timestamp="1511918507195"><title>@注解名</title></topic></topics></children></topic></topics></children></topic><topic id="7pclal6qnl79mem6cth6oodauv" modified-by="" timestamp="1511918530826"><title>（2）有参</title><children><topics type="attached"><topic id="1fvg8dgt1djlgl44kjgoa0kq5h" modified-by="" timestamp="1511918514593"><title>声明格式</title><children><topics type="attached"><topic id="2iavvinjrph9m45ut0h0okoipv" modified-by="" timestamp="1511918578595"><title>@元注解&#13;
[修饰符]  @interface  注解名{&#13;
		配置参数&#13;
}</title><children><topics type="attached"><topic id="0knl9d6ec78hqo4ug86jifjcoc" modified-by="" timestamp="1511918687425"><title>配置参数</title><children><topics type="attached"><topic id="74sk7tp32nknjsnlcacruao4qr" modified-by="" timestamp="1511918561960"><title>格式</title><children><topics type="attached"><topic id="27cp9onneei49lnabkogfs6uf6" modified-by="" timestamp="1511918573108"><title>数据类型  参数名();</title></topic></topics></children></topic><topic id="1tghesidjl4gm6bcu67jjlv855" modified-by="" timestamp="1511918586763"><title>一个注解可以有多个配置参数</title></topic><topic id="1je11cgonasdm9jq9v5tb144v1" modified-by="" timestamp="1511918600587"><title>配置参数可以有默认值</title><children><topics type="attached"><topic id="7i680rck3l4i8cq10aj24q4o9p" modified-by="" timestamp="1511918611245"><title>数据类型  参数名() default 默认值;</title></topic></topics></children></topic><topic id="1k825ojujl9og9pdv67egb7m2g" modified-by="" timestamp="1511918695620"><title>配置参数的类型有要求</title><children><topics type="attached"><topic id="3if8dgjk9ssujq37ia7jdlca3k" modified-by="" timestamp="1511918696921"><title svg:width="500">类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7ltk1t546185smo0it59r09dkn" modified-by="" timestamp="1511918529701"><title>使用格式</title><children><topics type="attached"><topic id="5ko4dgsa3q2n7usge8k1csrusk" modified-by="" timestamp="1511918775201"><title>@注解(参数赋值)</title><children><topics type="attached"><topic id="1pdhsu7qcc9jvulh0goosst6mr" modified-by="" timestamp="1511918749893"><title svg:width="500">如果配置参数有默认值，那么可以在使用时不需要赋值</title></topic><topic id="6274oemmur297o42kcje0ocijn" modified-by="" timestamp="1511918774266"><title svg:width="500">如果配置参数只有一个，而且名称是value，那么可以在赋值时省略value=</title></topic><topic id="24960ap9cuta9osrk3n38g61eh" modified-by="" timestamp="1511918801539"><title>参数赋值的格式</title><children><topics type="attached"><topic id="74fdkro8tlv64ueg93jpaqv88v" modified-by="" timestamp="1511918793597"><title>参数名 = 参数值</title></topic><topic id="7vtglb5js346j2bl145eb2777c" modified-by="" timestamp="1511918801291"><title>如果多个使用,分割</title></topic><topic id="2amvhrl3huo5bmbdvilnlhs5uj" modified-by="" timestamp="1511918826288"><title>如果配置参数的类型是数组类型</title><children><topics type="attached"><topic id="1qd2cathn1sfskpv769snqjtuu" modified-by="" timestamp="1511918825010"><title>如果只有一个元素，那么可以省略{}</title></topic><topic id="55om8socthbec4paj2f6pm180n" modified-by="" timestamp="1511918834732"><title>如果是多个元素，那么需要{}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="58p4npruqf2q9ibu5dehr25o6t" modified-by="" timestamp="1511918908335"><title>元注解</title><children><topics type="attached"><topic id="33ep2egso61hhdabpdavtc2gti" modified-by="" timestamp="1511919217073"><title>@Target</title><children><topics type="attached"><topic id="5a8mg0dl44id41sro9029ukbk4" modified-by="" timestamp="1511918924799"><title>指定某个注解它的使用目标位置</title></topic><topic id="7vsb86l3nlklflirpitiovpijf" modified-by="" timestamp="1511919026737"><title>如何指定它</title><children><topics type="attached"><topic id="6mdeh5d8jjf2s6oqdj9kmo4eup" modified-by="" timestamp="1511918988982"><title>它配置参数的类型是一个枚举数组</title><children><topics type="attached"><topic id="4ot6hl0ooq0af15mk27936o2p3" modified-by="" timestamp="1511918954355"><title>ElementType枚举类型</title><children><topics type="attached"><topic id="14c0rq5v76iu60f5q003csl48c" modified-by="" timestamp="1511918974289"><title>常量对象有：TYPE, FIELD,METHOD等</title></topic></topics></children></topic></topics></children></topic><topic id="78qeg09specr4vje2jnliiqebu" modified-by="" timestamp="1511919003118"><title>配置参数的名称是value</title></topic><topic id="7kar397hrkm6mcqtktk3954vjb" modified-by="" timestamp="1511919014065"><title>如果只有一个</title><children><topics type="attached"><topic id="378n56isj6n8rck9i7qi2ostfi" modified-by="" timestamp="1511919024844"><title>@Target(ElementType.METHOD)</title></topic></topics></children></topic><topic id="167s7dg6q1akuhkg4asu99rion" modified-by="" timestamp="1511919033154"><title>如果是多个</title><children><topics type="attached"><topic id="0jupci7l04j9jf1k6np65ude4h" modified-by="" timestamp="1511919055560"><title svg:width="500">@Target({ElementType.METHOD,ElementType.FIELD,。。。。})</title></topic></topics></children></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="1nfc1tjc6bhfau80pbh9h4k8cg" modified-by="" timestamp="1511919219270"><title>@Retention</title><children><topics type="attached"><topic id="3b4tcrhgvepct1dr4cp6jd1k14" modified-by="" timestamp="1511919073126"><title>指定某个注解的生命周期，可以保留到什么阶段</title></topic><topic id="44lug4evbflt26autqqg6fn3ff" modified-by="" timestamp="1511919128332"><title>如何指定它</title><children><topics type="attached"><topic id="0bi5v9g4r9n33klmtnuiqk2v74" modified-by="" timestamp="1511919092780"><title>它的配置参数的类型是一个枚举类型</title><children><topics type="attached"><topic id="6rd6etfhitav6qfn1v39822vts" modified-by="" timestamp="1511919106250"><title>RetentionPolicy类型</title><children><topics type="attached"><topic id="519sbjdn5pdhohrb2b4opkevci" modified-by="" timestamp="1511919112261"><title>常量对象有三个</title><children><topics type="attached"><topic id="63ab3q3dj6ort8sq8u326ao80e" modified-by="" timestamp="1511919120770"><title>SOURCE,CLASS,RUNTIME</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7ib9frllt186khvvfcd7l995p5" modified-by="" timestamp="1511919126873"><title>配置参数的名称是value</title></topic><topic id="3sp64cn2ac3nvtmque9q8sstnm" modified-by="" timestamp="1511919156357"><title>@Retention(RetentionPolicy.RUNTIME)</title></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="362auqgi6sfak0bfrhulvc2ego" modified-by="" timestamp="1511919164800"><title>@Documented</title><children><topics type="attached"><topic id="59qfan5o72veerh3pjef9o7dq9" modified-by="" timestamp="1511919177672"><title>表示是否javadoc读取</title></topic></topics></children></topic><topic id="4780tsqmodetgghdb8vtn4krou" modified-by="" timestamp="1511919180412"><title>@Inherited</title><children><topics type="attached"><topic id="5n7nf0c580t68olcpl85bbd641" modified-by="" timestamp="1511919184721"><title>是否被子类继承</title></topic></topics></children></topic><topic id="0iv5v9ua4mg3865odb7ls98hcl" modified-by="" timestamp="1511918910394"><title>在java.lang.annotation包</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>面向对象高级特性</title></sheet></xmap-revision-content>