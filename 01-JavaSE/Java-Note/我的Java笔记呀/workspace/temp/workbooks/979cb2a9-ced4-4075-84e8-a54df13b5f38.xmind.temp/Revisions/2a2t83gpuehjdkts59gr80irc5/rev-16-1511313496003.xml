<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="2a2t83gpuehjdkts59gr80irc5" modified-by="" style-id="1pkvsjgemjhomahhj6p9o7gp4f" theme="xminddefaultthemeid" timestamp="1511313214549" xmlns="urn:xmind:xmap:xmlns:content:2.0"><topic id="03re993mbt43s5uaer8m06ghoe" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1511228350707"><title>数组</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="5pluln4jse3u848o6c3f6ulcm3" modified-by="" timestamp="1511141557489"><title>数组的概念</title><children><topics type="attached"><topic id="707ri3m70u4eledim9nm6f42qt" modified-by="" timestamp="1511141538481"><title>数组的作用</title><children><topics type="attached"><topic id="3hqbbpgljpvl7bdaghd3n730lo" modified-by="" timestamp="1511141552130"><title>用来保存、管理一组相同数据类型的数据</title></topic></topics></children></topic><topic id="49mgb5eetma5qsfk5lvoq210em" modified-by="" timestamp="1511141680789"><title svg:width="500">把一组具有相同数据类型的变量使用同一个名字来进行管理，并且这些元素按照一定的顺序进行排列。这同一个名字我们称为【数组名】，每一个元素通过编号进行区别，这个编号我们称为【下标】或索引。元素的总个数就是【数组的长度】。</title></topic></topics></children></topic><topic id="3aq1tv5ruqon3an6l7ee6i2h44" modified-by="" timestamp="1511141744553"><title>数组如何声明和初始化</title><children><topics type="attached"><topic id="716mjrlrdssnf3o27le0k74i13" modified-by="" timestamp="1511141720314"><title>数组的声明</title><children><topics type="attached"><topic id="6cpnteo89n8oo7ngu0haqneb0j" modified-by="" timestamp="1511141709814"><title>数组的类型   数组名;</title></topic><topic id="6sub7hokid8tbvms5l5rph6cok" modified-by="" timestamp="1511141730098"><title>数组的元素的类型[]  数组名;</title><children><topics type="attached"><topic id="5hb83tl8e8c2cu5joe7g6hpqu0" modified-by="" timestamp="1511141735482"><title>推荐的方式</title></topic></topics></children></topic><topic id="4ra9jm1msi22k808ljka3coj3j" modified-by="" timestamp="1511141729370"><title>数组的元素的类型  数组名[];</title></topic></topics></children></topic><topic id="2qk1ubp1o2ba431n861u31kht4" modified-by="" timestamp="1511141753440"><title>初始化</title><children><topics type="attached"><topic id="5c1iahu9mf001s7kmfgn2v4nqb" modified-by="" timestamp="1511141758406"><title>动态初始化</title><children><topics type="attached"><topic id="4c478tr60joel6k2jk68b8hlio" modified-by="" timestamp="1511141803578"><title>格式：</title><children><topics type="attached"><topic id="7dlo75649cm75veptpfmla27dj" modified-by="" timestamp="1511141780096"><title>数组名 = new  元素的类型[数组的长度];</title></topic></topics></children></topic></topics></children></topic><topic id="0otsd7p9cr43s0ljfes1ujfg0v" modified-by="" timestamp="1511141805545"><title>静态初始化</title><children><topics type="attached"><topic id="73li4g8jif1e3tf4anpb5dvu3r" modified-by="" timestamp="1511141850802"><title>格式</title><children><topics type="attached"><topic id="21hrpdthrse1hnq80k4fu7q5o9" modified-by="" timestamp="1511141837012"><title>数组名 = new  元素的类型[]{元素列表};</title><children><topics type="attached"><topic id="1kogdm2d2pqjrc04j2qvd4c9u9" modified-by="" timestamp="1511141835604"><title>元素列表的每一个元素使用,分割</title></topic><topic id="0oerojrc5ju8sb8opikriohduq" modified-by="" timestamp="1511141843795"><title>元素列表的个数就是数组的长度</title></topic></topics></children></topic><topic id="3onesbec3rpdhbd8bgvjo6ogiu" modified-by="" timestamp="1511141856993"><title>简写形式</title><children><topics type="attached"><topic id="5u4ci9da12t489si5lt1c0ssmo" modified-by="" timestamp="1511141870864"><title>数组的元素的类型[]  数组名 = {元素列表};</title><children><topics type="attached"><topic id="7qdfpb8u0tu8e29tvnoqg0saap" modified-by="" timestamp="1511141890179"><title>只有声明和静态初始化在一行，才可以这么简写</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0pkk118jk2kob4tm7jt6mttllg" modified-by="" timestamp="1511141966700"><title>数组的元素</title><children><topics type="attached"><topic id="5jgdfcrllqrpmrnbm3gr6o3rnr" modified-by="" timestamp="1511141912614"><title>表示形式</title><children><topics type="attached"><topic id="7pqr4eopbntindt8gml9m4k858" modified-by="" timestamp="1511141919710"><title>数组名[下标]</title><children><topics type="attached"><topic id="38of3ka5fm6cm5sb9ggod34ai7" modified-by="" timestamp="1511141961699"><title>下标的范围</title><children><topics type="attached"><topic id="7vsqlhupmgftm5stdmjt3bg3u8" modified-by="" timestamp="1511141961720"><title>[0，数组的长度-1]</title><children><topics type="attached"><topic id="2p2gpberlhpekbtpo6bkshcf4o" modified-by="" timestamp="1511141961699"><title>[0,  数组名.length -1]</title></topic></topics></children></topic><topic id="5q1hkfgtg2q7gpa6de8q3tsd6m" modified-by="" timestamp="1511141948567"><title>[0，数组的长度)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="5bumnkdr29dl42r0km3bpgunrg" modified-by="" timestamp="1511141975801"><title>赋值</title><children><topics type="attached"><topic id="449srsoikt8erdfbctq938ejk4" modified-by="" timestamp="1511141982630"><title>数组名[下标] = 值;</title></topic></topics></children></topic></topics></children></topic><topic id="6g2aqu3ask8gb1teco17f9qcd1" modified-by="" timestamp="1511142007898"><title>数组的长度</title><children><topics type="attached"><topic id="7vgh9qm6s1duuu9r5t9ivnt5hk" modified-by="" timestamp="1511142011938"><title>数组名.length</title></topic></topics></children></topic><topic id="4vrkqdpnu4348s88s3umvrcf6r" modified-by="" timestamp="1511142027689"><title>数组的遍历</title><children><topics type="attached"><topic id="12c0bg9rf3keunk0resg87ovcv" modified-by="" timestamp="1511142047670"><title>for循环</title><children><topics type="attached"><topic id="3bege1t8a9n82fqpsql6d5o7cn" modified-by="" timestamp="1511142069984"><title>for(int i=0; i&lt;数组名.length; i++){&#13;
}</title></topic></topics></children></topic><topic id="73plt2d7l7h94o3q33gselme7a" modified-by="" timestamp="1511142070935"><title>foreach循环</title><children><topics type="attached"><topic id="7fbcnl2cuquibtn2vjq7bfgal9" modified-by="" timestamp="1511142092888"><title>for(数组的元素的类型   元素的临时名 : 数组名){&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="0n1lf6n70s8gdfo44d9qbk2gkr" modified-by="" timestamp="1511226061157"><title>数组的算法</title><children><topics type="attached"><topic id="5v0agm7tu4ugtd3amhmt22811r" modified-by="" timestamp="1511142250165"><title>（1）在数组中找最大值/最小值</title><notes><html><xhtml:p>	//找最大值</xhtml:p><xhtml:p>	public static int max(int[] arr){</xhtml:p><xhtml:p>		//第一步：假设第一个元素最大</xhtml:p><xhtml:p>		int max = arr[0];</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//遍历后面的元素和max比较</xhtml:p><xhtml:p>		for (int i = 1; i &lt; arr.length; i++) {</xhtml:p><xhtml:p>			//当有比max的值，就把max修改为它的值</xhtml:p><xhtml:p>			if(max &lt; arr[i]){</xhtml:p><xhtml:p>				max = arr[i];</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		return max;</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//找最大值&#13;
	public static int max(int[] arr){&#13;
		//第一步：假设第一个元素最大&#13;
		int max = arr[0];&#13;
		&#13;
		//遍历后面的元素和max比较&#13;
		for (int i = 1; i &lt; arr.length; i++) {&#13;
			//当有比max的值，就把max修改为它的值&#13;
			if(max &lt; arr[i]){&#13;
				max = arr[i];&#13;
			}&#13;
		}&#13;
		&#13;
		return max;&#13;
	}</plain></notes></topic><topic id="1li20b233k93uj5ampotj5306d" modified-by="" timestamp="1511142356681"><title>（2）在数组中找最大值、最小值的下标</title><notes><html><xhtml:p>	//找最大值的下标</xhtml:p><xhtml:p>	public static int maxIndex(int[] arr){</xhtml:p><xhtml:p>		//第一步：假设第一个元素最大</xhtml:p><xhtml:p>		int index = 0;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//arr[index] 和 后续的元素一一比较</xhtml:p><xhtml:p>		for (int i = 1; i &lt; arr.length; i++) {</xhtml:p><xhtml:p>			//当有比max的值，就把max修改为它的值</xhtml:p><xhtml:p>			if(arr[index] &lt; arr[i]){</xhtml:p><xhtml:p>				index = i;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		return index;</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//找最大值的下标&#13;
	public static int maxIndex(int[] arr){&#13;
		//第一步：假设第一个元素最大&#13;
		int index = 0;&#13;
		&#13;
		//arr[index] 和 后续的元素一一比较&#13;
		for (int i = 1; i &lt; arr.length; i++) {&#13;
			//当有比max的值，就把max修改为它的值&#13;
			if(arr[index] &lt; arr[i]){&#13;
				index = i;&#13;
			}&#13;
		}&#13;
		return index;&#13;
	}</plain></notes></topic><topic id="4t3k4jj79pulbtrdb6tc63in55" modified-by="" timestamp="1511142475019"><title>（3）数组元素的累加和，平均值</title><notes><html><xhtml:p>//求数组元素的总和</xhtml:p><xhtml:p>	public static long sum(int[] arr){</xhtml:p><xhtml:p>		long sum = 0;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		for (int i = 0; i &lt; arr.length; i++) {</xhtml:p><xhtml:p>			sum += arr[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		return sum;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	public static double avg(int[] arr){</xhtml:p><xhtml:p>		double sum = sum(arr);</xhtml:p><xhtml:p>		return sum/arr.length;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/></html><plain>//求数组元素的总和&#13;
	public static long sum(int[] arr){&#13;
		long sum = 0;&#13;
		&#13;
		for (int i = 0; i &lt; arr.length; i++) {&#13;
			sum += arr[i];&#13;
		}&#13;
		&#13;
		return sum;&#13;
	}&#13;
	public static double avg(int[] arr){&#13;
		double sum = sum(arr);&#13;
		return sum/arr.length;&#13;
	}&#13;
</plain></notes></topic><topic id="15t8ga6qotnpm71u8h7sciats9" modified-by="" timestamp="1511142939404"><title>（4）反转</title><notes><html><xhtml:p>	//反转</xhtml:p><xhtml:p>	public static void reverse(int[] arr){</xhtml:p><xhtml:p>		//如果有5个元素，应该交换2次或3次      arr.length/2</xhtml:p><xhtml:p> 		//如果有6个元素，应该交换3次                 arr.length/2</xhtml:p><xhtml:p>		//数组的收尾对应位置交换</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//次数</xhtml:p><xhtml:p>		for(int i=0; i&lt;arr.length/2; i++){</xhtml:p><xhtml:p>			//首尾交换</xhtml:p><xhtml:p>			int temp = arr[i];</xhtml:p><xhtml:p>			arr[i] = arr[arr.length-1-i];</xhtml:p><xhtml:p>			arr[arr.length-1-i] = temp;</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	</xhtml:p><xhtml:p>	//反转部分</xhtml:p><xhtml:p>	public static void reverse(int[] arr, int start ,int end){</xhtml:p><xhtml:p>		//次数     </xhtml:p><xhtml:p>		//假设start = 1, end = 5     次数2次    (end + 1 - start)/2  (5+1-1)/2  2</xhtml:p><xhtml:p>		//假设start = 1, end = 6  次数3次      (end + 2 - start)/2  (6+1-1)/2  3</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		for(int i=0; i&lt; (end + 1 - start)/2; i++){</xhtml:p><xhtml:p>			//首尾交换</xhtml:p><xhtml:p>			//arr[start],arr[start+1]...</xhtml:p><xhtml:p>			//arr[end],arr[end-1]...</xhtml:p><xhtml:p>			int temp = arr[start + i];</xhtml:p><xhtml:p>			arr[start + i] = arr[end -i];</xhtml:p><xhtml:p>			arr[end-i] = temp;</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//反转&#13;
	public static void reverse(int[] arr){&#13;
		//如果有5个元素，应该交换2次或3次      arr.length/2&#13;
 		//如果有6个元素，应该交换3次                 arr.length/2&#13;
		//数组的收尾对应位置交换&#13;
		&#13;
		//次数&#13;
		for(int i=0; i&lt;arr.length/2; i++){&#13;
			//首尾交换&#13;
			int temp = arr[i];&#13;
			arr[i] = arr[arr.length-1-i];&#13;
			arr[arr.length-1-i] = temp;&#13;
		}&#13;
	}&#13;
&#13;
	&#13;
	//反转部分&#13;
	public static void reverse(int[] arr, int start ,int end){&#13;
		//次数     &#13;
		//假设start = 1, end = 5     次数2次    (end + 1 - start)/2  (5+1-1)/2  2&#13;
		//假设start = 1, end = 6  次数3次      (end + 2 - start)/2  (6+1-1)/2  3&#13;
		&#13;
		for(int i=0; i&lt; (end + 1 - start)/2; i++){&#13;
			//首尾交换&#13;
			//arr[start],arr[start+1]...&#13;
			//arr[end],arr[end-1]...&#13;
			int temp = arr[start + i];&#13;
			arr[start + i] = arr[end -i];&#13;
			arr[end-i] = temp;&#13;
		}&#13;
	}</plain></notes></topic><topic id="25hge0qc6kjbm50qdn95dvjh61" modified-by="" timestamp="1511143108011"><title>（5）复制</title><notes><html><xhtml:p>	//复制一个数组，从原数组的[0]元素开始复制，新数组的长度由使用者决定</xhtml:p><xhtml:p>	public static int[] copy(int[] src, int newLength){</xhtml:p><xhtml:p>		//1、创建新数组的对象</xhtml:p><xhtml:p>		int[] newArray = new int[newLength];</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、把原数组的元素复制到新数组中</xhtml:p><xhtml:p>		for(int i=0; i&lt;newArray.length &amp;&amp; i&lt;src.length; i++){</xhtml:p><xhtml:p>			newArray[i] = src[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		return newArray;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//复制一个数组，从原数组的[start]元素开始复制，新数组的长度由使用者决定</xhtml:p><xhtml:p>	public static int[] copy(int[] src, int start, int newLength){</xhtml:p><xhtml:p>		//1、创建新数组</xhtml:p><xhtml:p>		int[] newArray = new int[newLength];</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、把原数组的元素从[start]复制到新数组的[0]...</xhtml:p><xhtml:p>		for(int i=0; i&lt;newArray.length &amp;&amp; start+i&lt;src.length; i++){</xhtml:p><xhtml:p>			newArray[i] = src[start+i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		return newArray;</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//复制一个数组，从原数组的[0]元素开始复制，新数组的长度由使用者决定&#13;
	public static int[] copy(int[] src, int newLength){&#13;
		//1、创建新数组的对象&#13;
		int[] newArray = new int[newLength];&#13;
		&#13;
		//2、把原数组的元素复制到新数组中&#13;
		for(int i=0; i&lt;newArray.length &amp;&amp; i&lt;src.length; i++){&#13;
			newArray[i] = src[i];&#13;
		}&#13;
		&#13;
		return newArray;&#13;
	}&#13;
	&#13;
	//复制一个数组，从原数组的[start]元素开始复制，新数组的长度由使用者决定&#13;
	public static int[] copy(int[] src, int start, int newLength){&#13;
		//1、创建新数组&#13;
		int[] newArray = new int[newLength];&#13;
		&#13;
		//2、把原数组的元素从[start]复制到新数组的[0]...&#13;
		for(int i=0; i&lt;newArray.length &amp;&amp; start+i&lt;src.length; i++){&#13;
			newArray[i] = src[start+i];&#13;
		}&#13;
		&#13;
		return newArray;&#13;
	}</plain></notes></topic><topic id="29mbi79kafe40cpo7mqbe6133e" modified-by="" timestamp="1511143124562"><title>（6）排序</title><children><topics type="attached"><topic id="0csuc5pksure782vh6upsfpi9s" modified-by="" timestamp="1511143189048"><title>冒泡排序</title><notes><html><xhtml:p>	//假设数组5个元素</xhtml:p><xhtml:p>	public static void pubSort3(int[] arr){</xhtml:p><xhtml:p>		//方式二：把大的往右沉</xhtml:p><xhtml:p>		//每一轮从左边开始比较</xhtml:p><xhtml:p>		//比较的轮数依然是n-1轮</xhtml:p><xhtml:p>		for(int i=1; i&lt;arr.length; i++){</xhtml:p><xhtml:p>			//每一轮从左边开始比较</xhtml:p><xhtml:p>			/*</xhtml:p><xhtml:p>			 * 第一轮：i=1， 比较4次，j=0,1,2,3   ,j&lt;arr.length-i  j&lt;5-1 j&lt;4 </xhtml:p><xhtml:p>			 * 第二轮：i=2，比较3次，j=0,1,2      ,j&lt;arr.length-i  j&lt;5-2 j&lt;3</xhtml:p><xhtml:p>			 * ...</xhtml:p><xhtml:p>			 */</xhtml:p><xhtml:p>			for(int j=0; j&lt;arr.length-i; j++){</xhtml:p><xhtml:p>				//如果左边的元比右边的元素大，交换</xhtml:p><xhtml:p>				if(arr[j] &gt; arr[j+1]){</xhtml:p><xhtml:p>					int temp = arr[j];</xhtml:p><xhtml:p>					arr[j] = arr[j+1];</xhtml:p><xhtml:p>					arr[j+1] = temp;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//假设数组5个元素</xhtml:p><xhtml:p>	public static void pubSort2(int[] arr){</xhtml:p><xhtml:p>		//排序规则：每一轮通过相邻元素的比较，把小的往左边冒（或把大的往右边沉），每一轮都是把本轮的最小值冒出来（最大值沉下去）</xhtml:p><xhtml:p>		//经过n-1轮完成最终的排序</xhtml:p><xhtml:p>		//(1)方式一：把小的往左边冒，注意，每一轮都是从最右边往左边比较</xhtml:p><xhtml:p>		//i=0,i=1,i=2,i=3  i&lt;5-1 --&gt;  i&lt;4 --&gt;  i&lt;=3</xhtml:p><xhtml:p>		for(int i=0; i&lt;arr.length-1; i++){//一共n-1轮</xhtml:p><xhtml:p>			//每一轮都要从最右边往左边比较</xhtml:p><xhtml:p>			/*</xhtml:p><xhtml:p>			 * 第一轮：比较n-1次，比较4次， i=0, j=4,3,2,1 ,j&gt;i</xhtml:p><xhtml:p>			 * 第二轮：比较3次，i=1, j=4,3,2 ,j&gt;i</xhtml:p><xhtml:p>			 * ....</xhtml:p><xhtml:p>			 */</xhtml:p><xhtml:p>			for(int j=arr.length-1; j&gt;i; j--){</xhtml:p><xhtml:p>				//相邻的元素比较，而且如果右边的比左边的小，需要交换</xhtml:p><xhtml:p>				if(arr[j] &lt; arr[j-1]){</xhtml:p><xhtml:p>					int temp = arr[j];</xhtml:p><xhtml:p>					arr[j] = arr[j-1];</xhtml:p><xhtml:p>					arr[j-1] = temp;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//冒泡排序：从小到大</xhtml:p><xhtml:p>	//如果数组是5个元素</xhtml:p><xhtml:p>	public static void pubSort(int[] arr){</xhtml:p><xhtml:p>		//排序规则：每一轮通过相邻元素的比较，把小的往左边冒（或把大的往右边沉），每一轮都是把本轮的最小值冒出来（最大值沉下去）</xhtml:p><xhtml:p>		//经过n-1轮完成最终的排序</xhtml:p><xhtml:p>		//(1)方式一：把小的往左边冒，注意，每一轮都是从最右边往左边比较</xhtml:p><xhtml:p>		for(int i=1; i&lt;arr.length; i++){//一共n-1轮</xhtml:p><xhtml:p>			//每一轮都要从最右边往左边比较</xhtml:p><xhtml:p>			/*</xhtml:p><xhtml:p>			 * 第一轮：比较n-1次，比较4次， i=1, j=4,3,2,1 ,j&gt;=i</xhtml:p><xhtml:p>			 * 第二轮：比较3次，i=2, j=4,3,2 ,j&gt;=i</xhtml:p><xhtml:p>			 * ....</xhtml:p><xhtml:p>			 */</xhtml:p><xhtml:p>			for(int j=arr.length-1; j&gt;=i; j--){</xhtml:p><xhtml:p>				//相邻的元素比较，而且如果右边的比左边的小，需要交换</xhtml:p><xhtml:p>				if(arr[j] &lt; arr[j-1]){</xhtml:p><xhtml:p>					int temp = arr[j];</xhtml:p><xhtml:p>					arr[j] = arr[j-1];</xhtml:p><xhtml:p>					arr[j-1] = temp;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//假设数组5个元素&#13;
	public static void pubSort3(int[] arr){&#13;
		//方式二：把大的往右沉&#13;
		//每一轮从左边开始比较&#13;
		//比较的轮数依然是n-1轮&#13;
		for(int i=1; i&lt;arr.length; i++){&#13;
			//每一轮从左边开始比较&#13;
			/*&#13;
			 * 第一轮：i=1， 比较4次，j=0,1,2,3   ,j&lt;arr.length-i  j&lt;5-1 j&lt;4 &#13;
			 * 第二轮：i=2，比较3次，j=0,1,2      ,j&lt;arr.length-i  j&lt;5-2 j&lt;3&#13;
			 * ...&#13;
			 */&#13;
			for(int j=0; j&lt;arr.length-i; j++){&#13;
				//如果左边的元比右边的元素大，交换&#13;
				if(arr[j] &gt; arr[j+1]){&#13;
					int temp = arr[j];&#13;
					arr[j] = arr[j+1];&#13;
					arr[j+1] = temp;&#13;
				}&#13;
			}&#13;
		}&#13;
	}&#13;
	&#13;
	//假设数组5个元素&#13;
	public static void pubSort2(int[] arr){&#13;
		//排序规则：每一轮通过相邻元素的比较，把小的往左边冒（或把大的往右边沉），每一轮都是把本轮的最小值冒出来（最大值沉下去）&#13;
		//经过n-1轮完成最终的排序&#13;
		//(1)方式一：把小的往左边冒，注意，每一轮都是从最右边往左边比较&#13;
		//i=0,i=1,i=2,i=3  i&lt;5-1 --&gt;  i&lt;4 --&gt;  i&lt;=3&#13;
		for(int i=0; i&lt;arr.length-1; i++){//一共n-1轮&#13;
			//每一轮都要从最右边往左边比较&#13;
			/*&#13;
			 * 第一轮：比较n-1次，比较4次， i=0, j=4,3,2,1 ,j&gt;i&#13;
			 * 第二轮：比较3次，i=1, j=4,3,2 ,j&gt;i&#13;
			 * ....&#13;
			 */&#13;
			for(int j=arr.length-1; j&gt;i; j--){&#13;
				//相邻的元素比较，而且如果右边的比左边的小，需要交换&#13;
				if(arr[j] &lt; arr[j-1]){&#13;
					int temp = arr[j];&#13;
					arr[j] = arr[j-1];&#13;
					arr[j-1] = temp;&#13;
				}&#13;
			}&#13;
		}&#13;
	}&#13;
	&#13;
	//冒泡排序：从小到大&#13;
	//如果数组是5个元素&#13;
	public static void pubSort(int[] arr){&#13;
		//排序规则：每一轮通过相邻元素的比较，把小的往左边冒（或把大的往右边沉），每一轮都是把本轮的最小值冒出来（最大值沉下去）&#13;
		//经过n-1轮完成最终的排序&#13;
		//(1)方式一：把小的往左边冒，注意，每一轮都是从最右边往左边比较&#13;
		for(int i=1; i&lt;arr.length; i++){//一共n-1轮&#13;
			//每一轮都要从最右边往左边比较&#13;
			/*&#13;
			 * 第一轮：比较n-1次，比较4次， i=1, j=4,3,2,1 ,j&gt;=i&#13;
			 * 第二轮：比较3次，i=2, j=4,3,2 ,j&gt;=i&#13;
			 * ....&#13;
			 */&#13;
			for(int j=arr.length-1; j&gt;=i; j--){&#13;
				//相邻的元素比较，而且如果右边的比左边的小，需要交换&#13;
				if(arr[j] &lt; arr[j-1]){&#13;
					int temp = arr[j];&#13;
					arr[j] = arr[j-1];&#13;
					arr[j-1] = temp;&#13;
				}&#13;
			}&#13;
		}&#13;
	}</plain></notes></topic><topic id="05bs9vq3mf4ugfvon3m6nmcvvs" modified-by="" timestamp="1511144958357"><title>直接选择排序</title><notes><html><xhtml:p>	//直接选择排序</xhtml:p><xhtml:p>	//基本原理：将待排序的元素分为已排序（初始为空）和未排序两组，依次将未排序的元素中值最小的元素放入已排序的组中。</xhtml:p><xhtml:p>	//[3,2,1,5,4]  从小到大排序</xhtml:p><xhtml:p>	/*</xhtml:p><xhtml:p>	 * 第一次：所有元素都属于未排序   把未排序的元素中的最小值找出来    arr[2] = 1 ，放入已排序组中     和第一个元素交换</xhtml:p><xhtml:p>	 * 		[1,2,3,5,4]</xhtml:p><xhtml:p>	 * 第二次：已排序的是[1]，未排序的是[2,3,5,4]，把未排序元素中的最小值找出  arr[1]=2，放入已排序组中  </xhtml:p><xhtml:p>	 * 		【1,2】，【3,5,4】</xhtml:p><xhtml:p>	 * ...</xhtml:p><xhtml:p>	 * </xhtml:p><xhtml:p>	 */</xhtml:p><xhtml:p>	//假设5个元素</xhtml:p><xhtml:p>	public static void selectSort(int[] arr){</xhtml:p><xhtml:p>		//次数</xhtml:p><xhtml:p>		for(int i=0; i&lt;arr.length-1; i++){</xhtml:p><xhtml:p>			//第一次，找最小值</xhtml:p><xhtml:p>			//假设每一轮的未排序元素的第一个最小</xhtml:p><xhtml:p>			int index = i;</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//找出本轮最小值</xhtml:p><xhtml:p>			/*</xhtml:p><xhtml:p>			 * int i=0 ,从哪些元素中找最小值  [0]~[4]   j=1,2,3,4</xhtml:p><xhtml:p>			 * int i=1，从哪些元素中找最小值[1]~[4]    j=2,3,4</xhtml:p><xhtml:p>			 * ...</xhtml:p><xhtml:p>			 */</xhtml:p><xhtml:p>			for(int j=i+1; j&lt;arr.length; j++){</xhtml:p><xhtml:p>				if(arr[index] &gt; arr[j]){</xhtml:p><xhtml:p>					index = j;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//找出arr[index]值最小，下标是index</xhtml:p><xhtml:p>			//arr[i] 和 arr[index]交换</xhtml:p><xhtml:p>			if(i!=index){</xhtml:p><xhtml:p>				int temp = arr[i];</xhtml:p><xhtml:p>				arr[i] = arr[index];</xhtml:p><xhtml:p>				arr[index] = temp;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//直接选择排序&#13;
	//基本原理：将待排序的元素分为已排序（初始为空）和未排序两组，依次将未排序的元素中值最小的元素放入已排序的组中。&#13;
	//[3,2,1,5,4]  从小到大排序&#13;
	/*&#13;
	 * 第一次：所有元素都属于未排序   把未排序的元素中的最小值找出来    arr[2] = 1 ，放入已排序组中     和第一个元素交换&#13;
	 * 		[1,2,3,5,4]&#13;
	 * 第二次：已排序的是[1]，未排序的是[2,3,5,4]，把未排序元素中的最小值找出  arr[1]=2，放入已排序组中  &#13;
	 * 		【1,2】，【3,5,4】&#13;
	 * ...&#13;
	 * &#13;
	 */&#13;
	//假设5个元素&#13;
	public static void selectSort(int[] arr){&#13;
		//次数&#13;
		for(int i=0; i&lt;arr.length-1; i++){&#13;
			//第一次，找最小值&#13;
			//假设每一轮的未排序元素的第一个最小&#13;
			int index = i;&#13;
			&#13;
			//找出本轮最小值&#13;
			/*&#13;
			 * int i=0 ,从哪些元素中找最小值  [0]~[4]   j=1,2,3,4&#13;
			 * int i=1，从哪些元素中找最小值[1]~[4]    j=2,3,4&#13;
			 * ...&#13;
			 */&#13;
			for(int j=i+1; j&lt;arr.length; j++){&#13;
				if(arr[index] &gt; arr[j]){&#13;
					index = j;&#13;
				}&#13;
			}&#13;
			&#13;
			//找出arr[index]值最小，下标是index&#13;
			//arr[i] 和 arr[index]交换&#13;
			if(i!=index){&#13;
				int temp = arr[i];&#13;
				arr[i] = arr[index];&#13;
				arr[index] = temp;&#13;
			}&#13;
			&#13;
		}&#13;
	}</plain></notes></topic></topics></children></topic><topic id="0irud7e9dbc6hn5jheeoatlva1" modified-by="" timestamp="1511158065487"><title>（7）数组的扩容</title><notes><html><xhtml:p>	private void kuorong(){</xhtml:p><xhtml:p>		//先扩容</xhtml:p><xhtml:p>		int[] newArray = new int[arr.length*2];</xhtml:p><xhtml:p>		//通过循环把原数组中的内容复制到新数组中</xhtml:p><xhtml:p>		for(int i=0; i&lt;arr.length; i++){</xhtml:p><xhtml:p>			newArray[i] = arr[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		//把新家的地址记录下来，下次存、取元素都从新家操作，旧家不要了</xhtml:p><xhtml:p>		arr = newArray;</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	private void kuorong(){&#13;
		//先扩容&#13;
		int[] newArray = new int[arr.length*2];&#13;
		//通过循环把原数组中的内容复制到新数组中&#13;
		for(int i=0; i&lt;arr.length; i++){&#13;
			newArray[i] = arr[i];&#13;
		}&#13;
		//把新家的地址记录下来，下次存、取元素都从新家操作，旧家不要了&#13;
		arr = newArray;&#13;
	}</plain></notes></topic><topic id="7hql5s3jd10vi0j6dq06js9gag" modified-by="" timestamp="1511225497853"><title>（8）数组的元素插入</title><notes><html><xhtml:p>package com.atguigu.array;</xhtml:p><xhtml:p/><xhtml:p>public class MyArrayList {</xhtml:p><xhtml:p>	private int[] arr = new int[5];//装数据</xhtml:p><xhtml:p>	private int total;//记录实际存储的元素的个数</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//在index插入数据data</xhtml:p><xhtml:p>	public void insert(int index, int data){</xhtml:p><xhtml:p>		//如果当前数组已满，需要先扩容</xhtml:p><xhtml:p>		if(total &gt;= arr.length){</xhtml:p><xhtml:p>			//(1)先创建一个新的更大的数组</xhtml:p><xhtml:p>			int[] newArray = new int[arr.length*2];</xhtml:p><xhtml:p>			//(2)把原来数组中的数据复制到新数组中</xhtml:p><xhtml:p>			for(int i=0; i&lt;arr.length; i++){</xhtml:p><xhtml:p>				newArray[i] = arr[i];</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			//(3)使得arr指向新数组</xhtml:p><xhtml:p>			arr = newArray;</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//1、先把index右边的元素右移</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 假设total=3,index=1</xhtml:p><xhtml:p>		 * 现在有值arr[0],arr[1],arr[2]，需要移动的是arr[2],arr[1]</xhtml:p><xhtml:p>		 * 假设total=5,index=1</xhtml:p><xhtml:p>		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的是,arr[4],arr[3],arr[2],arr[1]</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>		for(int i = total-1; i&gt;=index; i--){</xhtml:p><xhtml:p>			//右边的元素=左边的元素</xhtml:p><xhtml:p>			arr[i+1] = arr[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//在index位置插入data</xhtml:p><xhtml:p>		arr[index]= data;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//元素个数加1</xhtml:p><xhtml:p>		total++;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.array;&#13;
&#13;
public class MyArrayList {&#13;
	private int[] arr = new int[5];//装数据&#13;
	private int total;//记录实际存储的元素的个数&#13;
	&#13;
	&#13;
	//在index插入数据data&#13;
	public void insert(int index, int data){&#13;
		//如果当前数组已满，需要先扩容&#13;
		if(total &gt;= arr.length){&#13;
			//(1)先创建一个新的更大的数组&#13;
			int[] newArray = new int[arr.length*2];&#13;
			//(2)把原来数组中的数据复制到新数组中&#13;
			for(int i=0; i&lt;arr.length; i++){&#13;
				newArray[i] = arr[i];&#13;
			}&#13;
			//(3)使得arr指向新数组&#13;
			arr = newArray;&#13;
		}&#13;
		&#13;
		//1、先把index右边的元素右移&#13;
		/*&#13;
		 * 假设total=3,index=1&#13;
		 * 现在有值arr[0],arr[1],arr[2]，需要移动的是arr[2],arr[1]&#13;
		 * 假设total=5,index=1&#13;
		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的是,arr[4],arr[3],arr[2],arr[1]&#13;
		 */&#13;
		for(int i = total-1; i&gt;=index; i--){&#13;
			//右边的元素=左边的元素&#13;
			arr[i+1] = arr[i];&#13;
		}&#13;
		&#13;
		//在index位置插入data&#13;
		arr[index]= data;&#13;
		&#13;
		//元素个数加1&#13;
		total++;&#13;
	}&#13;
}&#13;
</plain></notes></topic><topic id="2cot4vvo5epen5d43t4q2d1j11" modified-by="" timestamp="1511225800311"><title>（9）数组的元素删除</title><children><topics type="attached"><topic id="2064tqvuhvfl80rtc3mna8j6o3" modified-by="" timestamp="1511225799130"><title>删除指定位置的元素</title><notes><html><xhtml:p>package com.atguigu.array;</xhtml:p><xhtml:p/><xhtml:p>public class MyArrayList {</xhtml:p><xhtml:p>	private int[] arr = new int[5];//装数据</xhtml:p><xhtml:p>	private int total;//记录实际存储的元素的个数</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//删除指定位置的元素</xhtml:p><xhtml:p>	public void delete(int index){</xhtml:p><xhtml:p>		//(1)把index右边的元素左移</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 假设现在total=3,index =1</xhtml:p><xhtml:p>		 * 有值的是arr[0],arr[1],arr[2]，需要移动的是arr[2]</xhtml:p><xhtml:p>		 * 假设现在total=5,index =1</xhtml:p><xhtml:p>		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的似乎arr[2],arr[3],arr[4]</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>		for(int i = index+1; i&lt;total; i++){</xhtml:p><xhtml:p>			//左边的元素=右边的元素</xhtml:p><xhtml:p>			arr[i-1] = arr[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//(2)把最后一个元素的位置置为“空”（还原到默认值）</xhtml:p><xhtml:p>		arr[total-1] = 0;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//(3)元素个数减一</xhtml:p><xhtml:p>		total--;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.array;&#13;
&#13;
public class MyArrayList {&#13;
	private int[] arr = new int[5];//装数据&#13;
	private int total;//记录实际存储的元素的个数&#13;
	&#13;
	//删除指定位置的元素&#13;
	public void delete(int index){&#13;
		//(1)把index右边的元素左移&#13;
		/*&#13;
		 * 假设现在total=3,index =1&#13;
		 * 有值的是arr[0],arr[1],arr[2]，需要移动的是arr[2]&#13;
		 * 假设现在total=5,index =1&#13;
		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的似乎arr[2],arr[3],arr[4]&#13;
		 */&#13;
		for(int i = index+1; i&lt;total; i++){&#13;
			//左边的元素=右边的元素&#13;
			arr[i-1] = arr[i];&#13;
		}&#13;
		&#13;
		//(2)把最后一个元素的位置置为“空”（还原到默认值）&#13;
		arr[total-1] = 0;&#13;
		&#13;
		//(3)元素个数减一&#13;
		total--;&#13;
	}&#13;
}&#13;
</plain></notes></topic><topic id="6teuucg9bvfkmcrb8nb4h34o2q" modified-by="" timestamp="1511226045292"><title>删除指定的元素值</title><notes><html><xhtml:p>package com.atguigu.array;</xhtml:p><xhtml:p/><xhtml:p>public class MyArrayList {</xhtml:p><xhtml:p>	private int[] arr = new int[5];//装数据</xhtml:p><xhtml:p>	private int total;//记录实际存储的元素的个数</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//删除指定位置的元素</xhtml:p><xhtml:p>	public void delete(int index){</xhtml:p><xhtml:p>		//(1)把index右边的元素左移</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 假设现在total=3,index =1</xhtml:p><xhtml:p>		 * 有值的是arr[0],arr[1],arr[2]，需要移动的是arr[2]</xhtml:p><xhtml:p>		 * 假设现在total=5,index =1</xhtml:p><xhtml:p>		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的似乎arr[2],arr[3],arr[4]</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>		for(int i = index+1; i&lt;total; i++){</xhtml:p><xhtml:p>			//左边的元素=右边的元素</xhtml:p><xhtml:p>			arr[i-1] = arr[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//(2)把最后一个元素的位置置为“空”（还原到默认值）</xhtml:p><xhtml:p>		arr[total-1] = 0;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//(3)元素个数减一</xhtml:p><xhtml:p>		total--;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public int findValue(int value){</xhtml:p><xhtml:p>		//挨个遍历，一共有total，遍历total个</xhtml:p><xhtml:p>		for (int i = 0; i &lt; total; i++) {</xhtml:p><xhtml:p>			if(arr[i] == value){</xhtml:p><xhtml:p>				return i;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		return -1;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public void deleteValue(int value){</xhtml:p><xhtml:p>		//1、先找到value在数组中的index，这里以第一次找到为准</xhtml:p><xhtml:p>		int index = findValue(value);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、删除index位置的元素</xhtml:p><xhtml:p>		if(index!=-1){</xhtml:p><xhtml:p>			delete(index);</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.array;&#13;
&#13;
public class MyArrayList {&#13;
	private int[] arr = new int[5];//装数据&#13;
	private int total;//记录实际存储的元素的个数&#13;
	&#13;
	//删除指定位置的元素&#13;
	public void delete(int index){&#13;
		//(1)把index右边的元素左移&#13;
		/*&#13;
		 * 假设现在total=3,index =1&#13;
		 * 有值的是arr[0],arr[1],arr[2]，需要移动的是arr[2]&#13;
		 * 假设现在total=5,index =1&#13;
		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的似乎arr[2],arr[3],arr[4]&#13;
		 */&#13;
		for(int i = index+1; i&lt;total; i++){&#13;
			//左边的元素=右边的元素&#13;
			arr[i-1] = arr[i];&#13;
		}&#13;
		&#13;
		//(2)把最后一个元素的位置置为“空”（还原到默认值）&#13;
		arr[total-1] = 0;&#13;
		&#13;
		//(3)元素个数减一&#13;
		total--;&#13;
	}&#13;
	&#13;
	public int findValue(int value){&#13;
		//挨个遍历，一共有total，遍历total个&#13;
		for (int i = 0; i &lt; total; i++) {&#13;
			if(arr[i] == value){&#13;
				return i;&#13;
			}&#13;
		}&#13;
		return -1;&#13;
	}&#13;
	&#13;
	public void deleteValue(int value){&#13;
		//1、先找到value在数组中的index，这里以第一次找到为准&#13;
		int index = findValue(value);&#13;
		&#13;
		//2、删除index位置的元素&#13;
		if(index!=-1){&#13;
			delete(index);&#13;
		}&#13;
	}&#13;
}&#13;
</plain></notes></topic></topics></children></topic><topic id="4pl8fk3hvbia840op4qefss62o" modified-by="" timestamp="1511226041761"><title>（10）在数组中查找某个值的下标</title><notes><html><xhtml:p>package com.atguigu.array;</xhtml:p><xhtml:p/><xhtml:p>public class MyArrayList {</xhtml:p><xhtml:p>	private int[] arr = new int[5];//装数据</xhtml:p><xhtml:p>	private int total;//记录实际存储的元素的个数</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//删除指定位置的元素</xhtml:p><xhtml:p>	public void delete(int index){</xhtml:p><xhtml:p>		//(1)把index右边的元素左移</xhtml:p><xhtml:p>		/*</xhtml:p><xhtml:p>		 * 假设现在total=3,index =1</xhtml:p><xhtml:p>		 * 有值的是arr[0],arr[1],arr[2]，需要移动的是arr[2]</xhtml:p><xhtml:p>		 * 假设现在total=5,index =1</xhtml:p><xhtml:p>		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的似乎arr[2],arr[3],arr[4]</xhtml:p><xhtml:p>		 */</xhtml:p><xhtml:p>		for(int i = index+1; i&lt;total; i++){</xhtml:p><xhtml:p>			//左边的元素=右边的元素</xhtml:p><xhtml:p>			arr[i-1] = arr[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//(2)把最后一个元素的位置置为“空”（还原到默认值）</xhtml:p><xhtml:p>		arr[total-1] = 0;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//(3)元素个数减一</xhtml:p><xhtml:p>		total--;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public int findValue(int value){</xhtml:p><xhtml:p>		//挨个遍历，一共有total，遍历total个</xhtml:p><xhtml:p>		for (int i = 0; i &lt; total; i++) {</xhtml:p><xhtml:p>			if(arr[i] == value){</xhtml:p><xhtml:p>				return i;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		return -1;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	public void deleteValue(int value){</xhtml:p><xhtml:p>		//1、先找到value在数组中的index，这里以第一次找到为准</xhtml:p><xhtml:p>		int index = findValue(value);</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、删除index位置的元素</xhtml:p><xhtml:p>		if(index!=-1){</xhtml:p><xhtml:p>			delete(index);</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>package com.atguigu.array;&#13;
&#13;
public class MyArrayList {&#13;
	private int[] arr = new int[5];//装数据&#13;
	private int total;//记录实际存储的元素的个数&#13;
	&#13;
	//删除指定位置的元素&#13;
	public void delete(int index){&#13;
		//(1)把index右边的元素左移&#13;
		/*&#13;
		 * 假设现在total=3,index =1&#13;
		 * 有值的是arr[0],arr[1],arr[2]，需要移动的是arr[2]&#13;
		 * 假设现在total=5,index =1&#13;
		 * 现在有值arr[0],arr[1],arr[2],arr[3],arr[4]，需要移动的似乎arr[2],arr[3],arr[4]&#13;
		 */&#13;
		for(int i = index+1; i&lt;total; i++){&#13;
			//左边的元素=右边的元素&#13;
			arr[i-1] = arr[i];&#13;
		}&#13;
		&#13;
		//(2)把最后一个元素的位置置为“空”（还原到默认值）&#13;
		arr[total-1] = 0;&#13;
		&#13;
		//(3)元素个数减一&#13;
		total--;&#13;
	}&#13;
	&#13;
	public int findValue(int value){&#13;
		//挨个遍历，一共有total，遍历total个&#13;
		for (int i = 0; i &lt; total; i++) {&#13;
			if(arr[i] == value){&#13;
				return i;&#13;
			}&#13;
		}&#13;
		return -1;&#13;
	}&#13;
	&#13;
	public void deleteValue(int value){&#13;
		//1、先找到value在数组中的index，这里以第一次找到为准&#13;
		int index = findValue(value);&#13;
		&#13;
		//2、删除index位置的元素&#13;
		if(index!=-1){&#13;
			delete(index);&#13;
		}&#13;
	}&#13;
}&#13;
</plain></notes></topic></topics></children></topic><topic id="4gisjc64mcgs5p4sr5esvh0tc7" modified-by="" timestamp="1511226768741"><title>二维数组</title><children><topics type="attached"><topic id="483jqci3096l9mjjujeehsgghk" modified-by="" timestamp="1511226087407"><title>如何声明</title><children><topics type="attached"><topic id="2jhkmrmvojvso1pvtotdd837t1" modified-by="" timestamp="1511226098474"><title>数组类型  数组名;</title><children><topics type="attached"><topic id="2ng3f4r0kel633omabilhtpgqe" modified-by="" timestamp="1511226239286"><title>数组类型是xx[][]</title></topic></topics></children></topic><topic id="4m3q7i2gpnj3c051iaugnjeamb" modified-by="" timestamp="1511226095162"><title>元素的类型[][]  数组名;</title></topic></topics></children></topic><topic id="7j7thb3235agso7qdui70eitu7" modified-by="" timestamp="1511226262853"><title>如何创建二维数组对象及初始化</title><children><topics type="attached"><topic id="0a35kcagp0iksr93q0eja1njjv" modified-by="" timestamp="1511226385331"><title>动态初始化</title><children><topics type="attached"><topic id="2e31huqhdl6s6045qtd413d1pe" modified-by="" timestamp="1511226375377"><title svg:width="500">数组名 = new 元素的数据类型[行长度][每一行的列长度];</title><children><topics type="attached"><topic id="6r951csd5vkfbe8d8etmajnht8" modified-by="" timestamp="1511226382083"><title>每一行的列数相同</title></topic></topics></children></topic><topic id="4po2efje349e61elvgb3cbquuq" modified-by="" timestamp="1511226419377"><title svg:width="500">数组名 = new 元素的数据类型[行长度][];</title><children><topics type="attached"><topic id="1ab4502ircus5iaqebvvio07qp" modified-by="" timestamp="1511226396604"><title>每一行的列数不确定</title></topic><topic id="4lr8g8e8f8683donquaa68r6or" modified-by="" timestamp="1511226415671"><title>每一行的行对象暂时是null</title></topic><topic id="5dbk5f8126g0gt64cbbk6kcc4j" modified-by="" timestamp="1511226437899"><title>创建每一行的行对象，即为行分配空间</title><children><topics type="attached"><topic id="7b7ilnnemu463f5qg0b4457uon" modified-by="" timestamp="1511226454777"><title>数组名[行下标] = new  元素的类型[该行的列数];</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="11kgaavju6f8lsi2jrtb41qr6k" modified-by="" timestamp="1511226272036"><title>静态初始化</title><children><topics type="attached"><topic id="7ufnrtfqqc952ajbplol4a7ke8" modified-by="" timestamp="1511226356385"><title svg:width="500">数组名 = new 元素的数据类型[][]{{x,x,x,x,....},{x,x,x},{x,x,x,x,x,x,x},.....};</title><children><topics type="attached"><topic id="1k6316bf1ghdehlss764dm8neg" modified-by="" timestamp="1511226331625"><title>{}中嵌套{}，里面的一个{}代表一行</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6pbiji96t0ic77p1dr68p6424j" modified-by="" timestamp="1511226482802"><title>二维数组的长度，即行数</title><children><topics type="attached"><topic id="5i2r4i4oifbj1kujv3ul39o8jj" modified-by="" timestamp="1511226490353"><title>二维数组名.length</title></topic></topics></children></topic><topic id="2al4cpihrd28vmlfts00s0csqr" modified-by="" timestamp="1511226497943"><title>二维数组的行对象</title><children><topics type="attached"><topic id="1baiav4j11jq0b1nomtmo421r3" modified-by="" timestamp="1511226555460"><title>二维数组名[行下标]</title><children><topics type="attached"><topic id="6galqbrni9mpk9jbpt4f2m80vo" modified-by="" timestamp="1511226573657"><title>行下标的范围[0,二维数组名.length-1]</title></topic></topics></children></topic></topics></children></topic><topic id="00g5hg5ltegbsembjipqr607qe" modified-by="" timestamp="1511226517368"><title>二维数组的每一行的列数</title><children><topics type="attached"><topic id="1njseph02ihs3h47p5emks1m2c" modified-by="" timestamp="1511226523046"><title>二维数组名[行下标].length</title></topic></topics></children></topic><topic id="63lghte2dka642ukuusq5kg53f" modified-by="" timestamp="1511226547118"><title>二维数组的每一个元素</title><children><topics type="attached"><topic id="12klj7o485jeopg2hu63jskdb4" modified-by="" timestamp="1511226576176"><title>二维数组名[行下标][列下标]</title><children><topics type="attached"><topic id="1psls4ldtooshs0kdqkns9o8tf" modified-by="" timestamp="1511226599644"><title>注意列下标</title><children><topics type="attached"><topic id="5qbi4p5jouoo4ddrdv95fqdun3" modified-by="" timestamp="1511226596977"><title>每一行的列下标的范围可能是不一样</title></topic><topic id="5995okv3o47p7vslmm3d11im0q" modified-by="" timestamp="1511226608797"><title>[0, 二维数组名[行下标].length)</title></topic></topics></children></topic></topics></children></topic><topic id="7v4o6ph4q3s8qpvtrr57qgt9hq" modified-by="" timestamp="1511226553855"><title>二维数组名[行下标][列下标] = 值</title></topic></topics></children></topic><topic id="3fbvr9h1q0kq4shm6fi043lce5" modified-by="" timestamp="1511226687060"><title>二维数组的遍历</title><children><topics type="attached"><topic id="56oca06pcvfsqr60a95stv87g3" modified-by="" timestamp="1511226629858"><title>for</title><children><topics type="attached"><topic id="4g55ruu8fagvh0qfapj2q8jh4f" modified-by="" timestamp="1511226684865"><title>for(int i=0; i&lt;数组名.length; i++){&#13;
	for(int j=0; j&lt;数组名[i].length; j++){&#13;
			数组名[i][j]表示一个元素&#13;
	}&#13;
}</title></topic></topics></children></topic><topic id="6ggsijtbopfnklcvl493p23tn3" modified-by="" timestamp="1511226693725"><title>增强for</title><children><topics type="attached"><topic id="3k7edhmt6hd4js82jsh1j3j6i5" modified-by="" timestamp="1511226741152"><title>for(行类型  hang : 二维数组名){&#13;
	for(元素类型  lie : hang){&#13;
            lie就是代表每一个元素&#13;
    }&#13;
}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="37s5r0ja2nd89md1ki4doc73sa" modified-by="" timestamp="1511228016709"><title>数组的内存图</title><children><topics type="attached"><topic branch="folded" id="7v0pevvj6vat54couatdv7f5i1" modified-by="" timestamp="1511227073393"><title>一维数组</title><children><topics type="attached"><topic branch="folded" id="440ul21evsljpasjomqg079pp3" modified-by="" timestamp="1511227061899"><title>元素是基本数据类型</title><children><topics type="attached"><topic id="61qtmiq34tefjv2tmb5l8pjiuh" modified-by="" timestamp="1511227059160"><xhtml:img xhtml:src="xap:attachments/5vkghi14jvlk65fppg6o4hfa9p.png"/></topic></topics></children></topic><topic id="0sj8sarfq12clu0pskqrdjo0fp" modified-by="" timestamp="1511227069664"><title>元素是引用数据类型，又称为对象数组</title><children><topics type="attached"><topic id="1bb4rrgl0kfvae3nprcq9gg774" modified-by="" timestamp="1511227069622"><xhtml:img xhtml:src="xap:attachments/6s2ns7qd47cat28qbd7bscqqvl.png"/></topic></topics></children></topic></topics></children></topic><topic id="0or7lh2uvt624munh8l3clrv3r" modified-by="" timestamp="1511227446422"><title>二维数组</title><children><topics type="attached"><topic id="0jd1dhnlebqhbgjbmcfgpmc45a" modified-by="" timestamp="1511227439230"><title>元素是基本数据类型</title><children><topics type="attached"><topic id="584t7brk6ic6nnm2knksfpt83s" modified-by="" timestamp="1511227243774"><title>规则</title><children><topics type="attached"><topic id="55h04mmioc27vlhabadfkne3dq" modified-by="" timestamp="1511227243738"><xhtml:img xhtml:src="xap:attachments/2f61lgrpcdvhikrrsd8j1qiicm.png"/></topic></topics></children></topic><topic id="4vl8lloa4gc5cvimsif4j1ufj9" modified-by="" timestamp="1511227444533"><title>不规则</title><children><topics type="attached"><topic id="5lv9fiadke44o5v3cki75q7jrr" modified-by="" timestamp="1511227444487"><xhtml:img xhtml:src="xap:attachments/7i6p41u8u8qol1cvf996b479bl.png"/></topic></topics></children></topic></topics></children></topic><topic id="235eu8ri1vn6qdd46lqg102k5h" modified-by="" timestamp="1511228008253"><title>元素是引用数据类型</title><children><topics type="attached"><topic id="36vjsjpug2rtm902patibtcis0" modified-by="" timestamp="1511227786346"><title>规则</title><children><topics type="attached"><topic id="1cki1v0d1vabmu9oe08phl5jsu" modified-by="" timestamp="1511227786282"><xhtml:img xhtml:src="xap:attachments/5huir3mgcdvsebp1m5h6t99ls7.png"/></topic></topics></children></topic><topic id="1mk7sal9l95lbn7t0mkq12kd3g" modified-by="" timestamp="1511228012031"><title>不规则</title><children><topics type="attached"><topic id="1k6p1nn9tr26ladjovrv8me4go" modified-by="" timestamp="1511228011968"><xhtml:img xhtml:src="xap:attachments/57tshhrtufepo7cgob4ptrhpdj.png"/></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7fn2q400tmnimohqjg0586tvdk" modified-by="" timestamp="1511228033567"><title>数组的工具类</title><children><topics type="attached"><topic id="7450298378f359b1hg583tg7gn" modified-by="" timestamp="1511228030454"><title>java.util.Arrays</title></topic><topic id="0eosksm4i6g3dkr01r89fqtlje" modified-by="" timestamp="1511228187056"><title>静态方法</title><children><topics type="attached"><topic id="0niishdadh19qqof9q0ncr5vo9" modified-by="" timestamp="1511228092081"><title>（1）int   Arrays.binarySearch(int[] a ,int key)</title><children><topics type="attached"><topic id="6udpdqupihesg1bp6ec2onvu9r" modified-by="" timestamp="1511228073939"><title>在a数组中查找key的下标</title></topic><topic id="0ff4inv0280jdmjkaav4lca227" modified-by="" timestamp="1511228091168"><title svg:width="500">（1）数组a必须是有序的，否则结果不一定正确</title></topic><topic id="0clhu40ujjtru40hvsmmggrc7u" modified-by="" timestamp="1511228124982"><title svg:width="500">（2）如果key在a中存在，就返回它的下标，如果不存在，返回(-(插入点)-1)</title></topic></topics></children></topic><topic id="5lhrqk3rjslcurvo5oqejsokqm" modified-by="" timestamp="1511228147358"><title>（2）Arrays.fill(int[] a, int value)</title><children><topics type="attached"><topic id="286jus2beof50vb6qj9src98e6" modified-by="" timestamp="1511228161037"><title>给数组a的每一个元素都赋值为value</title></topic></topics></children></topic><topic id="0ncql4hb466n8uoas5q770t4gl" modified-by="" timestamp="1511228176458"><title>（3）Arrays.sort(int[])</title><children><topics type="attached"><topic id="74k18cltkl7dct7dkou8t6ma4i" modified-by="" timestamp="1511228185330"><title>排序，从小到大</title></topic></topics></children></topic><topic id="2d8uhmhnbqlpg1si6pp9o8apn8" modified-by="" timestamp="1511228201415"><title>（4）String  Arrays.toString(int[] a)</title><children><topics type="attached"><topic id="0a0ur8b5mji0b2hqan1n4ssl26" modified-by="" timestamp="1511228221587"><title svg:width="500">把数组的元素列表用字符串返回，形式[元素1，元素2，元素3.。。]</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic branch="folded" id="0t3lu72s5et0hk9qo5sgmspuua" modified-by="" timestamp="1511228358974"><title>命令行参数</title><children><topics type="attached"><topic id="43k8upf501d2u3iek0kqnloj67" modified-by="" timestamp="1511228248345"><title>主方法的参数</title></topic><topic id="766lki8udia5f7p0m2ppjm6a4d" modified-by="" timestamp="1511228258525"><title>java命令</title><children><topics type="attached"><topic id="1k4g3qv9hjiu9uo6d3l7kprc2u" modified-by="" timestamp="1511228278460"><title>java   包.类名   参数1  参数2   参数3 ....</title><children><topics type="attached"><topic id="0ht527tesof4baj7b396jtiscl" modified-by="" timestamp="1511228288447"><title>参数之间使用空格</title></topic></topics></children></topic></topics></children></topic><topic id="7rncoehh86ce8difd1h1fkstsn" modified-by="" timestamp="1511228339535"><title>eclipse</title><children><topics type="attached"><topic id="699f8pfi5nfpfp5hvs0v1cto5k" modified-by="" timestamp="1511228339482"><xhtml:img xhtml:src="xap:attachments/5e9ev25kilep8qj08nhbaqm0r5.png"/></topic></topics></children></topic></topics></children></topic><topic id="5hn2ofgsjo6adtq1bgig653gff" modified-by="" timestamp="1511228434610"><title>可变参数</title><children><topics type="attached"><topic id="5kuk7vdmpab576h3v31kr6ibgb" modified-by="" timestamp="1511228368248"><title>可变参数属于形参</title></topic><topic id="3ofgr3jvg1kd5f7e3tkja8n0jq" modified-by="" timestamp="1511228399607"><title>要求</title><children><topics type="attached"><topic id="1d3r7dsssipcsfg0prq40163s5" modified-by="" timestamp="1511228386449"><title svg:width="500">一个方法只能有一个可变参数，而且只能是最后一个</title></topic><topic id="7h6dvuv10327doulua18kd77bu" modified-by="" timestamp="1511228398889"><title>在声明它的方法中，当做数组处理</title></topic><topic id="422o66g6qs595bc28f79rjfjaf" modified-by="" timestamp="1511228428499"><title svg:width="500">对于调用这个方法者，可变参数的位置可以传，[0~n]个实参，也可以传对应类型数组对象</title></topic></topics></children></topic><topic id="52g60br5mgigvdi8ls66pu8gl4" modified-by="" timestamp="1511228501925"><title>可变参数的重载问题</title><children><topics type="attached"><topic id="1htlbs3bnbgm63aes88tl1iiu4" modified-by="" timestamp="1511228785110"><title>对于编译器来说不属于重载</title><children><topics type="attached"><topic id="3mrljrv4vh8s06vrh4vhnnv06v" modified-by="" timestamp="1511228783208"><title>不属于重载</title><children><topics type="attached"><topic id="0fjdpt6mg7melhbt2aurbg0vn0" modified-by="" timestamp="1511228783161"><title>	public static void main(String[] args) {&#13;
		System.out.println(getSum(1));&#13;
	}&#13;
	&#13;
	public static int getSum(int... args){&#13;
		return 0;&#13;
	}&#13;
	public static int getSum(int a,int... args){&#13;
		return 0;&#13;
	}</title><children><topics type="attached"><topic id="1c99stqnl6bb7p961pntnk8e9g" modified-by="" timestamp="1511228663740"><title>如果传一个整数时，不知道用谁好</title></topic></topics></children></topic><topic id="3hq1esshevbcfkepp585qvcf5v" modified-by="" timestamp="1511228781432"><title>	public static int getSum(int... args){&#13;
		return 0;&#13;
	}&#13;
	&#13;
	public static int getSum(int[] args){&#13;
		&#13;
	}</title><children><topics type="attached"><topic id="78o3rfo70fen2knviofsqvhdcr" modified-by="" timestamp="1511228554520"><title>但是它俩不完全等价</title><children><topics type="attached"><topic id="5vl9gcu1gfr5aohqo7uhmoibv5" modified-by="" timestamp="1511228551571"><title svg:width="500">因为int... args既可以传数组对象，又可以传 n个元素值</title></topic><topic id="1m78p5916jkd0odqum2too0f9n" modified-by="" timestamp="1511228564330"><title>int[]只能传数组对象</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="4fsvvgsqacpje3m8q5piqvc2e5" modified-by="" timestamp="1511228797921"><title>属于重载</title><children><topics type="attached"><topic id="3masd48vmacuq8d14a6bj0mk1t" modified-by="" timestamp="1511228801920"><title>	public static void main(String[] args) {&#13;
		System.out.println(getSum(1));&#13;
	}&#13;
	&#13;
	public static int getSum(int... args){&#13;
		return 0;&#13;
	}&#13;
	public static int getSum(int a){&#13;
		System.out.println("一个参数");&#13;
		return 0;&#13;
	}</title><children><topics type="attached"><topic id="27e61nl4f7qoobbi1pco98jr36" modified-by="" timestamp="1511228811276"><title>优先于确定参数个数</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>数组</title></sheet></xmap-revision-content>