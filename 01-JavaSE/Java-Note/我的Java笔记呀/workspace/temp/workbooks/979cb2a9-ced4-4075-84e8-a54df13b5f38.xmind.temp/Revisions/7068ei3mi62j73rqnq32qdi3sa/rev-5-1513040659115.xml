<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="7068ei3mi62j73rqnq32qdi3sa" modified-by="" style-id="0kstj9p5njfq9famsfnsd1bk44" theme="xminddefaultthemeid" timestamp="1513040651852"><topic id="7ahcc0rkuhkv2avc0ktoru1mph" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1513040358424"><title>反射机制</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="75ap3focngkct538ucqm7flpn0" modified-by="" timestamp="1513039339241"><title>为什么要用反射？</title><children><topics type="attached"><topic id="4sdlu9vs868bknpakf5vpma8iv" modified-by="" timestamp="1513039405682"><title svg:width="500">因为Java是静态的强类型语言，在编译阶段就需要确定类型</title><children><topics type="attached"><topic id="2hhourjhfkc9fgknavinhevfsu" modified-by="" timestamp="1513039842426"><title>Java为了实现“动态性“特征，引入了反射机制</title><children><topics type="attached"><topic id="0j6j7m3ida2jhtaj867u2toir1" modified-by="" timestamp="1513039489365"><title svg:width="500">变量可以使用Object声明，然后在运行时确定某个对象的运行时类型</title></topic><topic id="299qhflgqs8p0h6jdsuso98t3u" modified-by="" timestamp="1513039526843"><title svg:width="500">或者在运行时动态的”注入“某个类型的对象，动态的创建某个类型的对象</title><children><topics type="attached"><topic id="0rqdo3o0n1b1ht9vq756ijc4lc" modified-by="" timestamp="1513039540571"><title svg:width="500">例如：用这个类型的Class对象，然后创建它的实例</title></topic></topics></children></topic><topic id="3ba2b56nru91htu1pgp3p2moo1" modified-by="" timestamp="1513039847191"><title>。。。。</title></topic></topics></children></topic></topics></children></topic><topic id="5kb0310eu1487vots4ffu5aici" modified-by="" timestamp="1513039373516"><title svg:width="500">例如：JS等是动态的弱类型的语言，在运行时确定变量的类型，根据赋的值确定变量的类型</title></topic></topics></children></topic><topic id="7c39fhkbkffiien8r2thkfvpci" modified-by="" timestamp="1513040148085"><title>反射的根源</title><children><topics type="attached"><topic id="0pap2qm32f8964e1k2a682ttk9" modified-by="" timestamp="1513039901216"><title>java.lang.Class</title><children><topics type="attached"><topic id="4fk691plab5a9mkj2i050fpjul" modified-by="" timestamp="1513039968687"><title svg:width="500">Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。 </title><children><topics type="attached"><topic id="6u5rnpu2etvcna9pnc02bt805k" modified-by="" timestamp="1513040025766"><title>示例代码</title><children><topics type="attached"><topic id="14254lghnq3papk9dinbpbqrbc" modified-by="" timestamp="1513040027802"><title svg:width="500">	@Test&#13;
	public void test() {&#13;
		Class c1 = int.class;&#13;
		Class c2 = void.class;&#13;
		Class c3 = String.class;&#13;
		Class c4 = Comparable.class;&#13;
		Class c5 = ElementType.class;&#13;
		Class c6 = Override.class;&#13;
		Class c7 = int[].class;&#13;
		&#13;
		int[] arr1 = new int[5];&#13;
		int[] arr2 = new int[10];&#13;
		&#13;
		System.out.println(arr1.getClass() == arr2.getClass());&#13;
		System.out.println(int[].class == arr2.getClass());&#13;
		&#13;
		int[][] arr3 = new int[5][10];&#13;
		System.out.println(arr1.getClass());&#13;
		System.out.println(arr3.getClass());&#13;
	}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0tldv37hoijg0donmd5bm1v9lk" modified-by="" timestamp="1513040293963"><title>四种获取Class对象的方式</title><children><topics type="attached"><topic id="4nuo1ov94ss3skv10uf9253cn2" modified-by="" timestamp="1513040177875"><title>（1）如果类型已知：</title><children><topics type="attached"><topic id="6nv65q8432u5es9abs4ognurph" modified-by="" timestamp="1513040196830"><title>类型名.class</title></topic></topics></children></topic><topic id="06n9d2tnkrshi85uq6n53c3ijd" modified-by="" timestamp="1513040226757"><title>（2）如果对象存在</title><children><topics type="attached"><topic id="37hiqo54hj1auh31qv8g3mme9l" modified-by="" timestamp="1513040233118"><title>对象.getClass()</title></topic></topics></children></topic><topic id="5pqnq8hr0ojruk38rclntepd8v" modified-by="" timestamp="1513040276796"><title svg:width="500">（3）如果在编译阶段未知，但是运行阶段可以获取它的类型全名称</title><children><topics type="attached"><topic id="6vrfjvdhmsq7pn2l3qlvn9qf6o" modified-by="" timestamp="1513040289312"><title>Class.forName("类型全名称")</title></topic></topics></children></topic><topic id="4vevq5f7ctvbp66g57guboe6v4" modified-by="" timestamp="1513040297402"><title svg:width="500">（4）如果在编译阶段未知，但是运行阶段可以获取它的类型全名称</title><children><topics type="attached"><topic id="4b0cigc8le7925k8hlpqgr12v5" modified-by="" timestamp="1513040308123"><title>类加载对象.loadClass("类型全名称")</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="5brc2s5m70clnb00pqml2u3c7j" modified-by="" timestamp="1513040380340"><title>相关的API（了解）</title><children><topics type="attached"><topic id="0di5flmtn0mj5ds0ls36dfnu36" modified-by="" timestamp="1513040460333"><title>java.lang.Class</title><children><topics type="attached"><topic id="52vv6dvrc7avde7fsaig7uljvt" modified-by="" timestamp="1513040554143"><title>方法</title><children><topics type="attached"><topic id="2169d5qkg33q0203o35qe4gdqo" modified-by="" timestamp="1513040482014"><title>（1）获取类型名：</title><children><topics type="attached"><topic id="5pdl6a2a34m79mhmhs4feaar3q" modified-by="" timestamp="1513040485319"><title>getName()</title></topic></topics></children></topic><topic id="121ivu1m3jlf3db0926oajdg9q" modified-by="" timestamp="1513040506621"><title>（2）创建实例对象</title><children><topics type="attached"><topic id="7bvouss179i1l63lgdcu5rd7fa" modified-by="" timestamp="1513040513903"><title>newInstance()</title><children><topics type="attached"><topic id="7s8m5h7n3p3t0amnvdjbnjjfup" modified-by="" timestamp="1513040524158"><title>这个类型必须有无参构造</title></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic><topic id="4g5ffurh9v01io4k749flc8f55" modified-by="" timestamp="1513040542752"><title>（3）获取包的信息</title><children><topics type="attached"><topic id="0ak9sfsqpd0akedtoo7mil5m1s" modified-by="" timestamp="1513040553048"><title>getPackage()</title></topic></topics></children></topic><topic id="63mbgfujlp968fsb00t4ti7sgo" modified-by="" timestamp="1513040626787"><title>（4）获取父类</title><children><topics type="attached"><topic id="72ftq5u3026rqdjupnpsbmrpt4" modified-by="" timestamp="1513040624379"><title>Class  getSuperClass()</title><children><topics type="attached"><topic id="5gr5thgvemka3grho3la06vsfv" modified-by="" timestamp="1513040618901"><title>不带泛型</title></topic></topics></children></topic><topic id="2o4c38nler142k42lgevq84tde" modified-by="" timestamp="1513040646607"><title>Type  getGenericSuperClass()</title><children><topics type="attached"><topic id="5onsk80rnlftlaau6hgi4s99l9" modified-by="" timestamp="1513040651852"><title>可以带泛型</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="190p8gf0l2622g3haf0551gfum" modified-by="" timestamp="1513040455894"><title>java.lang.reflect</title><children><topics type="attached"><topic id="13k4rippcvn7l8c46nnnl6ttd1" modified-by="" timestamp="1513040392895"><title>Package</title></topic><topic id="3hfivgo3vu0udh9m2uggs2tefk" modified-by="" timestamp="1513040400250"><title>Modifier</title></topic><topic id="5u66ebm1uaq8b1amin055nue6h" modified-by="" timestamp="1513040408927"><title>Constructor</title></topic><topic id="0gtt4bjgqgosp7ad5gp860h68i" modified-by="" timestamp="1513040417252"><title>Field</title></topic><topic id="1c7b917e985mvaks5rs3ia17ul" modified-by="" timestamp="1513040421008"><title>Method</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>画布 15</title></sheet></xmap-revision-content>