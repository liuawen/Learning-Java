<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="3acqbte3erbs5kg5jfvrkfceje" modified-by="" style-id="0np7olv4942cm091r7iqm49rcu" theme="xminddefaultthemeid" timestamp="1512525845205" xmlns="urn:xmind:xmap:xmlns:content:2.0"><topic id="0gnm66o3pat99evhljt4eq2ic2" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1512436125086"><title>集合</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="28fi7oaguvbatr7uok1hetdgo7" modified-by="" timestamp="1512435722362"><title>概念</title><children><topics type="attached"><topic id="2320uor4q5knkm76c4hvm35b4j" modified-by="" timestamp="1512435585722"><title>集合是一个容器</title><children><topics type="attached"><topic id="26bno4okrunh67m1ao6r4f8bvc" modified-by="" timestamp="1512435579263"><title>是一个用来装对象的容器</title></topic></topics></children></topic><topic id="05q2loqgb40vjkop6ulm3oa2i3" modified-by="" timestamp="1512442034188"><title>数据结构</title><children><topics type="attached"><topic id="2cfvd1u8aqhm4e9r410ij20p3v" modified-by="" timestamp="1512435727057"><title>1、物理结构</title><children><topics type="attached"><topic id="1on8gniu67c1ge8qm17pcp9pov" modified-by="" timestamp="1512435759131"><title>数组也是一个容器</title><children><topics type="attached"><topic id="7caqfr83ft1pauo9pqf064lbau" modified-by="" timestamp="1512435608737"><title>缺点</title><children><topics type="attached"><topic id="57er2imq8r6gamrtirs6n7qks2" modified-by="" timestamp="1512435606061"><title>（1）长度固定</title></topic><topic id="6v9qgin8pgr93itsj1bfv5d0g4" modified-by="" timestamp="1512435621476"><title>（2）无法直接获取有效元素的个数</title></topic></topics></children></topic><topic id="25hqe82hjhlobog8a91hu4719g" modified-by="" timestamp="1512435700735"><title svg:width="500">在实际开发中，基本数据类型一般用数组，引用数据类型一般用集合</title></topic><topic id="1gqkeg7854jo22imi6qpu8coiu" modified-by="" timestamp="1512435805694"><title svg:width="500">数组是依据“数组名+下标”来确定某个元素，数组名中存储的是数组的首地址</title></topic></topics></children></topic><topic id="6s7qfjvt6koatc8lv845l26ecp" modified-by="" timestamp="1512435735438"><title>链表</title><children><topics type="attached"><topic id="0c1nu6o7sevvqcg0d71h0a6sfv" modified-by="" timestamp="1512435755741"><title>不仅仅存储数据，还有存储前/后元素的引用</title></topic></topics></children></topic></topics></children></topic><topic id="0atup8t0d3ionrf9q6r8irfuiq" modified-by="" timestamp="1512435865090"><title>2、逻辑结构</title><children><topics type="attached"><topic id="2b283nlr7nglre4q1aridng0h1" modified-by="" timestamp="1512435875200"><title>动态数组</title><children><topics type="attached"><topic id="2enroc5egcoth4ilfrtjmfbm4u" modified-by="" timestamp="1512435899931"><title>底层是数组，可以通过扩容的方式实现动态数组</title></topic></topics></children></topic><topic id="7rbqu7av9uehg88hraama9ulg7" modified-by="" timestamp="1512435901960"><title>链表</title><children><topics type="attached"><topic id="7fbmpm7b157fn1jhtosho3jnls" modified-by="" timestamp="1512435971204"><title>结合Node</title><children><topics type="attached"><topic id="0ptbpja9fuvhgi4inmrgam6j63" modified-by="" timestamp="1512435970325"><title>双向链表</title><children><topics type="attached"><topic id="125k13mtkmdftd8qld6fe32p1u" modified-by="" timestamp="1512435970296"><title>class Node{&#13;
	Node pre;&#13;
	Object data;&#13;
	Node next;&#13;
}</title></topic></topics></children></topic><topic id="43b9kcf6a75hv1d8e28kqoh2q9" modified-by="" timestamp="1512435976392"><title>单向链表</title><children><topics type="attached"><topic id="3kn9198njr3jccvet46b5hif0r" modified-by="" timestamp="1512435979921"><title>class Node{&#13;
	Object data;&#13;
	Node next;&#13;
}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7udau202h7b5t5pv0qvskk4p00" modified-by="" timestamp="1512435987461"><title>树</title><children><topics type="attached"><topic id="5tv2vt2n41d95d9til54oqvccv" modified-by="" timestamp="1512435994428"><title>经典的代表</title><children><topics type="attached"><topic id="7m9tfs3ff6udfrkmfo5sovjqj0" modified-by="" timestamp="1512436005165"><title>二叉树</title><children><topics type="attached"><topic id="7rot11gerttga36nmc0sf7kk12" modified-by="" timestamp="1512436013434"><title>class Node{&#13;
	Node left;&#13;
	Object data;&#13;
	Node right;&#13;
}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="7p8j1k1tuoe5hd8ouan9vvupfi" modified-by="" timestamp="1512436067275"><title>栈</title><children><topics type="attached"><topic id="6s5s1qeuo90e6u5975bdpoidj0" modified-by="" timestamp="1512436027868"><title>先进后出</title></topic><topic id="06974rlo02dsaknknac1ehu52s" modified-by="" timestamp="1512436067035"><title>添加的顺序</title></topic><topic id="7hp9vjrpmbbaf5l3tkitoqllse" modified-by="" timestamp="1512436073338"><title>出栈的顺序</title></topic></topics></children></topic><topic id="3kvj8ti3k8p2r1jj3k9bo6mp0v" modified-by="" timestamp="1512436080058"><title>队列</title><children><topics type="attached"><topic id="4hg837j7od54dbs6ia5i6lic7u" modified-by="" timestamp="1512436041285"><title>先进先出</title></topic><topic id="2eo4ekkh7k51qd857s2npo9m20" modified-by="" timestamp="1512436079791"><title>添加的顺序</title></topic><topic id="36g8jq65r9dgf3uavpml38945f" modified-by="" timestamp="1512436086226"><title>出队列的顺序</title></topic></topics></children></topic><topic id="19s1vomrofdkmvs9m6tgg2fuvl" modified-by="" timestamp="1512435864850"><title>堆</title></topic><topic id="3trgl3jhe7ksvhvth1fp7bu419" modified-by="" timestamp="1512435868223"><title>....</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="50u003g0h1ac0jabd5rj4qs9qe" modified-by="" timestamp="1512439223793"><title>Collection</title><children><topics type="attached"><topic id="7nbsitji7q8jgqo696bjmfl2un" modified-by="" timestamp="1512436149870"><title>java.util.Collection是一个接口，是个根接口</title></topic><topic id="4ja37c0dk066s6056delvhv7l0" modified-by="" timestamp="1512436194451"><title>Collection没有直接的实现类，它有两个子接口</title><children><topics type="attached"><topic id="387jb1hmuirl1uu8athe019shu" modified-by="" timestamp="1512439511456"><title>java.util.List</title><children><topics type="attached"><topic id="2nijmipjs61objrmbgcg25lci3" modified-by="" timestamp="1512436946716"><title>有序的（添加顺序），可重复的</title><children><topics type="attached"><topic id="7gi020d0rns2ii851e2j8icoqe" modified-by="" timestamp="1512436479044"><title>java.util.Vector动态数组</title><children><topics type="attached"><topic id="6irfjprotfp2vaasegd3r27l7h" modified-by="" timestamp="1512436307092"><title>JDK1.0就有，最早</title></topic><topic id="6fqn5moq7p2a9k0j4lfq0t4ppd" modified-by="" timestamp="1512436331248"><title>支持Enumeration迭代方式</title><children><topics type="attached"><topic id="6bsqiifi44bs3johlh3tjgio0k" modified-by="" timestamp="1512436341403"><title>当然也支持Iterator，foreach</title></topic></topics></children></topic><topic id="0k2j46njhuf2ep93oemp3l7988" modified-by="" timestamp="1512436329404"><title>线程安全的</title></topic><topic id="632sn6athc5cmapi8jr4hplm0l" modified-by="" timestamp="1512436380440"><title>扩容算法</title><children><topics type="attached"><topic id="3kf0vn27g33dddsa9qr6nmb4jb" modified-by="" timestamp="1512436410435"><title svg:width="500">如果没有指定扩容参数，那么默认扩大为原来的2倍</title><children><topics type="attached"><topic id="4mcst4a2r6eeal1hnjgci3n2bk" modified-by="" timestamp="1512436416849"><title>默认初始容量是10</title></topic></topics></children></topic><topic id="20pioha6op2fi31qqet15jjhq7" modified-by="" timestamp="1512436400499"><title svg:width="500">如果指定了扩容参数，那么就按照指定参数值进行扩容</title></topic></topics></children></topic></topics></children></topic><topic id="1ektihcp37e44tba9mmk6d0r7r" modified-by="" timestamp="1512436485383"><title>java.util.ArrayList动态数组</title><children><topics type="attached"><topic id="3him3sq8j4id6g5t5te7lidvup" modified-by="" timestamp="1512436437755"><title>相对Vector来说新一点</title></topic><topic id="7stgeiv4qofr1libje6n2dgt68" modified-by="" timestamp="1512436449468"><title>只支持Iterator，foreach</title></topic><topic id="5on81dcihmrqucqna71j5abtor" modified-by="" timestamp="1512436454462"><title>线程不安全的</title></topic><topic id="7dhcot7t3egkd7hjpciem82n1r" modified-by="" timestamp="1512436461435"><title>扩容算法</title><children><topics type="attached"><topic id="7hh8qoduaja3ffpd53nn24luhq" modified-by="" timestamp="1512436468121"><title>扩大为原来的1.5倍</title></topic></topics></children></topic></topics></children></topic><topic id="734m9emps0lppnup612m15e4hv" modified-by="" timestamp="1512436578072"><title>java.util.LinkedList双向链表</title><children><topics type="attached"><topic id="58rd2k3a8i0t4a8fkio9jk7d5c" modified-by="" timestamp="1512436519841"><title>相对于动态数组来说的优势</title><children><topics type="attached"><topic id="2engmfhddvsogsjcujv5v4o8hq" modified-by="" timestamp="1512436539330"><title svg:width="500">在插入和删除操作比较频繁时，链表的方式效率更高</title></topic></topics></children></topic><topic id="3jdpsm1o15tea7cbab6laraqdc" modified-by="" timestamp="1512436611353"><title>相对于动态数组来说的劣势</title><children><topics type="attached"><topic id="0nlppgnuv5lk9atmgf78ktuksu" modified-by="" timestamp="1512436631389"><title>如果根据索引信息来查找的话，每次都要现统计</title></topic></topics></children></topic></topics></children></topic><topic id="31p1na24cu2h6qo4njhhm6uics" modified-by="" timestamp="1512437245876"><title>java.util.Stack</title><children><topics type="attached"><topic id="1ttm17nahe4k2mncmmvva2bqkd" modified-by="" timestamp="1512436962292"><title>是Vector的子类</title></topic><topic id="53lfh90r99qqsvffr0ins42lu7" modified-by="" timestamp="1512437097263"><title>特征的方法</title><children><topics type="attached"><topic id="7talr4ul98e0q2rfqckcc39lo4" modified-by="" timestamp="1512436978206"><title>peek()</title><children><topics type="attached"><topic id="1g2fhmg3i6s4hbk2pes9ujdkcd" modified-by="" timestamp="1512436992999"><title>查看栈顶的元素，但不移除</title></topic></topics></children></topic><topic id="4p336kn71n5mgo23rmldb4sa9s" modified-by="" timestamp="1512437052737"><title>pop()</title><children><topics type="attached"><topic id="3eo971flkq52lg9e19tlhnhs64" modified-by="" timestamp="1512437063502"><title>获取栈顶的元素，并移除</title></topic></topics></children></topic><topic id="5ifol4t2hsgnmoslso12m2tok5" modified-by="" timestamp="1512437072770"><title>push()</title><children><topics type="attached"><topic id="02ml76ful88lj7s5sgbr62bg02" modified-by="" timestamp="1512437096707"><title>压入栈，添加的位置在栈顶</title></topic></topics></children></topic><topic id="4kg8ut5fs7a97i73t45s1ohtgl" modified-by="" timestamp="1512437105344"><title>search(Object)</title><children><topics type="attached"><topic id="3rieb0pdpl1tja725l3l5q44j6" modified-by="" timestamp="1512437116688"><title>返回位置，以 1 为基数</title></topic></topics></children></topic></topics></children></topic><topic id="6tomdknrtdcrv02n778u2u0u7r" modified-by="" timestamp="1512437045349"><title>逻辑结构</title><children><topics type="attached"><topic id="188a7f8d7vpj3ff8os5qsaq1kf" modified-by="" timestamp="1512437240736"><children><topics type="attached"><topic id="2rdebgtf4mjqig11m5o791360m" modified-by="" timestamp="1512437243402"><xhtml:img svg:height="167" svg:width="216" xhtml:src="xap:attachments/1jgtte76pr8jeh54b8cv82ugga.png"/></topic></topics></children></topic></topics></children></topic><topic id="6b3m7im9buqe0kuvib3dd09752" modified-by="" timestamp="1512437252735"><title>底层</title><children><topics type="attached"><topic id="551n8aej1kt0rk9vj73u0jgeoh" modified-by="" timestamp="1512437252455"><title>数组</title></topic><topic id="37tk6b86b0nd4rl2eeqt7keuda" modified-by="" timestamp="1512437292658"><title svg:width="500">每次添加到后面，栈顶是数组的后面[size-1]号元素，栈底是数组的[0]元素</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6jr5b6923tjrkagjhfu4ad7pta" modified-by="" timestamp="1512436279891"><title>列表，序列</title></topic><topic id="6401gjc5egl2h8213kae85047k" modified-by="" timestamp="1512439522749"><title>补充Collection的方法</title><children><topics type="attached"><topic id="1qp6k6652m10cmdmtvcnuduoeg" modified-by="" timestamp="1512439647289"><title>和index相关的方法</title><children><topics type="attached"><topic id="6qfqnanvjkfemece94v0shdn9b" modified-by="" timestamp="1512439558255"><title>(1)添加</title><children><topics type="attached"><topic id="326rea4ussj4ckeua4h12rfbhb" modified-by="" timestamp="1512439557297"><title>add(int index, E element) </title></topic><topic id="68okdi8ll40q6073qe9ussfot4" modified-by="" timestamp="1512439559533"><title>addAll(int index, Collection&lt;? extends E&gt; c) </title></topic></topics></children></topic><topic id="656ehhjduvbo7v5sdf7ccnavb9" modified-by="" timestamp="1512439572202"><title>（2）删除</title><children><topics type="attached"><topic id="4m3ed3d5tfughagbaholmquqm4" modified-by="" timestamp="1512439575236"><title>remove(int index) </title></topic></topics></children></topic><topic id="01175uorq8m3t1ni3cu884h2c6" modified-by="" timestamp="1512439608613"><title>（3）查找</title><children><topics type="attached"><topic id="4l2103mckv75voin9s3n3qj696" modified-by="" timestamp="1512439598969"><title>indexOf(Object o) </title></topic><topic id="1m53d4kvlhjs2pg5g134ansba1" modified-by="" timestamp="1512439602988"><title>lastIndexOf(Object o) </title></topic><topic id="6o0fjp03ct5slbtn4qqn6d6igt" modified-by="" timestamp="1512439613003"><title>get(int index) </title></topic></topics></children></topic><topic id="4afaosas9qc4fe7s1jqrjpk0jk" modified-by="" timestamp="1512439625707"><title>（4）替换</title><children><topics type="attached"><topic id="5mmt21401fsrik7i5srubojkit" modified-by="" timestamp="1512439627059"><title>set(int index, E element) </title></topic></topics></children></topic><topic id="57nhd9q35a8dv9ikqef6drt5ol" modified-by="" timestamp="1512439654400"><title>（5）截取</title><children><topics type="attached"><topic id="2aurp0elq15ov7i527s7ab8m77" modified-by="" timestamp="1512439656217"><title>subList(int fromIndex, int toIndex)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3l00ml6ob7d3mtfav4k4rpiq7e" modified-by="" timestamp="1512440583513"><title>java.util.Set</title><children><topics type="attached"><topic id="76vpovek8ok9q7qqosqrf6imnv" modified-by="" timestamp="1512438043425"><title>无序的（添加顺序），不可重复的</title><children><topics type="attached"><topic id="2l3lbamudgf1lmt6o209h4cull" modified-by="" timestamp="1512438351931"><title>java.util.HashSet</title><children><topics type="attached"><topic id="0jf0g01nisqgiq0t5cfirse7el" modified-by="" timestamp="1512438068846"><title>无序，不可重复</title></topic><topic id="2b6ovn9ckg9mftu53ccrlai528" modified-by="" timestamp="1512438091249"><title>依赖于元素的hashCode和equals方法</title></topic><topic id="73uvq5q3ckimf1kudj4c2pv6rj" modified-by="" timestamp="1512438431739"><title>equals和hashCode</title><children><topics type="attached"><topic id="4n8kmi5s706obvgvhm6vrkf9jh" modified-by="" timestamp="1512438384277"><title svg:width="500">hash值不同，这两个对象一定不同，可以不调用equals</title></topic><topic id="653aq3nj2i6t9g2t6abf8p8ib9" modified-by="" timestamp="1512438431263"><title>equals如果相同，hashCode一定相同</title></topic><topic id="3k0f1r2ds6qlcjn3fjn2cgr9cb" modified-by="" timestamp="1512438458557"><title svg:width="500">hash值相同，这两个对象不一定相等，所以一定要调用equals方法进行确认</title></topic></topics></children></topic></topics></children></topic><topic id="5q25aisspnh5nr5ph7setbujsb" modified-by="" timestamp="1512438620408"><title>java.util.TreeSet</title><children><topics type="attached"><topic id="4niopllnfvhsjhhdevldf59ls1" modified-by="" timestamp="1512438510409"><title svg:width="500">不按添加顺序，但是按照元素“大小”顺序存储，不可重复</title></topic><topic id="4jq3k9jd2e0cm8vkt5i6639s0t" modified-by="" timestamp="1512438824014"><title>不可重复，依据元素是否“大小相等”</title><children><topics type="attached"><topic id="49nl7d89v3d0s662gt6mhp4trm" modified-by="" timestamp="1512438839330"><title>调用元素的compareTo或定制比较器的compare</title></topic></topics></children></topic><topic id="7v24aiusst9cgoht3eqe0t68st" modified-by="" timestamp="1512438640957"><title svg:width="500">添加到TreeSet的元素一定要支持可比较大小，可排序</title><children><topics type="attached"><topic id="5aood7uh37d5t7ps501tftd9ph" modified-by="" timestamp="1512438644351"><title>自然排序</title><children><topics type="attached"><topic id="7hahetvunt86dr5ffqtrrp5se9" modified-by="" timestamp="1512438673500"><title svg:width="500">要求元素类型本身要实现java.lang.Comparable接口，并重写int compareTo(Object)方法</title></topic></topics></children></topic><topic id="71v0gr3dq3u38louros8i93n27" modified-by="" timestamp="1512438785920"><title>定制排序</title><children><topics type="attached"><topic id="7ac2euuhrb0vv0dn045n1i6lmo" modified-by="" timestamp="1512438801051"><title>要为TreeSet指定一个定制比较器对象</title><children><topics type="attached"><topic id="56ths4h7dknc484462jg4oeep9" modified-by="" timestamp="1512438815437"><title>TreeSet set = new TreeSet(定制比较器对象);</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="32k5ia32ajokh2s9alfo587kcl" modified-by="" timestamp="1512438910065"><title>java.util.LinkedHashSet</title><children><topics type="attached"><topic id="30g9c8uhtacibmvudg7ehuu24b" modified-by="" timestamp="1512438885123"><title svg:width="500">比较HashSet多了一个顺序维护，所以在添加和删除时，比HashSet效率低，遍历查找时效率高</title></topic><topic id="4nt57mi893jv4rq023d2iook7u" modified-by="" timestamp="1512438916227"><title>继承HashSet</title></topic></topics></children></topic></topics></children></topic><topic id="3fnvrrehsrfh77dhbtvacjufg4" modified-by="" timestamp="1512440566198"><title>底层实现</title><children><topics type="attached"><topic id="427eln1se4ir8gpc70pgnub5pc" modified-by="" timestamp="1512440550358"><title>HashSet</title><children><topics type="attached"><topic id="2lh8ovi0aj753lk2kf5go99thj" modified-by="" timestamp="1512440553769"><title>HashMap</title></topic></topics></children></topic><topic id="198sk7olcqb3ruval9p8uhv6rq" modified-by="" timestamp="1512440558564"><title>TreeSet</title><children><topics type="attached"><topic id="12bhohtear975f01oaift0og2b" modified-by="" timestamp="1512440566000"><title>TreeMap</title></topic></topics></children></topic><topic id="1550pis7i00dl5juc7efpll6ka" modified-by="" timestamp="1512440572304"><title>LinkedHashSet</title><children><topics type="attached"><topic id="5e8alb96afb770ctbdkbp60k65" modified-by="" timestamp="1512440576671"><title>LinkedHashMap</title></topic></topics></children></topic></topics></children></topic><topic id="0mkkd5gu8bvhf77gmi31vsr3vn" modified-by="" timestamp="1512440613874"><title svg:width="500">Set的元素其实也是一对，只不过它的value是共享同一个常量对象Object对象</title></topic></topics></children></topic></topics></children></topic><topic id="3918lrttk2u4gbmhrddjmgboub" modified-by="" timestamp="1512437476406"><title>遍历</title><children><topics type="attached"><topic id="5el3b8iq2hk42kjiol12dihu8f" modified-by="" timestamp="1512437402820"><title>（1）直接foreach</title><children><topics type="attached"><topic id="3hmdfgb6ma1hs33mhpfl482tsb" modified-by="" timestamp="1512437374692"><title>语法结构</title><children><topics type="attached"><topic id="4sapmmgftihaatd8cpoeg9vinb" modified-by="" timestamp="1512437400182"><title>for(集合的元素类型  element : 集合名){&#13;
}</title></topic></topics></children></topic><topic id="1gm7db8qfc7g0afkaejshgh713" modified-by="" timestamp="1512437453467"><title svg:width="500">在遍历时，效率高，但是不适用于遍历的同时对集合进行修改，特别是影响集合元素个数的操作</title></topic></topics></children></topic><topic id="1eb3mchshgpup0c6e6gofheh2r" modified-by="" timestamp="1512437626375"><title>（2）Iterator迭代器</title><children><topics type="attached"><topic id="3hh3ij8hfo06vocsc5sb5eamu2" modified-by="" timestamp="1512437507237"><title>语法结构</title><children><topics type="attached"><topic id="7fscjfkl19fivd2ptcdl92m2ei" modified-by="" timestamp="1512437503721"><title>Iterator iter = 集合对象.iterator();</title></topic><topic id="1t7sishjpi6lpcp3llngopnvmn" modified-by="" timestamp="1512437546761"><title>while(iter.hasNext()){&#13;
	Object element = iter.next();&#13;
	//可以使用iter.remove()进行移除&#13;
}</title></topic></topics></children></topic><topic id="2o8f0kr4g3pcsfh01pg3359ssm" modified-by="" timestamp="1512437930763"><title>Iterator是一个接口</title><children><topics type="attached"><topic id="51sv80snkmb9ohm54m18gjgq9q" modified-by="" timestamp="1512437958584"><title svg:width="500">在每一类集合中，都有自己的实现类，通过内部类的形式来实现Iterator接口</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="3kbmihro6l2sve7i7lqsv1gnif" modified-by="" timestamp="1512439213402"><title>继承关系图</title><children><topics type="attached"><topic id="0ioniml24fougq60an65tvqs0h" modified-by="" timestamp="1512439220728"><xhtml:img svg:height="215" svg:width="338" xhtml:src="xap:attachments/5q5s9rb2hu3klmnthvg4p2fllc.png"/></topic></topics></children></topic><topic id="2muf5g16fc258nn26k75e488fh" modified-by="" timestamp="1512439477658"><title>Collection的常用方法</title><children><topics type="attached"><topic id="0cg1c742n1atir6mi4c6r8r9td" modified-by="" timestamp="1512439292329"><title>（1）添加</title><children><topics type="attached"><topic id="79v0ebliki9q5p90unqsrb4a0f" modified-by="" timestamp="1512439283421"><title>(1)add(Object obj)</title><children><topics type="attached"><topic id="3rukbm6fjhuqnrljm9jc3rhg1u" modified-by="" timestamp="1512439290960"><title>添加一个元素到集合中</title></topic></topics></children></topic><topic id="42itvr68au9dbq974831bj1j7d" modified-by="" timestamp="1512439298306"><title>(2)addAll(Collection other)</title><children><topics type="attached"><topic id="67cka5if20sa9oj4kokq32fbcn" modified-by="" timestamp="1512439315299"><title svg:width="500">把other集合中的元素一一添加到当前集合中，一次添加多个</title></topic></topics></children></topic></topics></children></topic><topic id="1ggcv0i945etljb924cmcjh2lg" modified-by="" timestamp="1512439336924"><title>（2）删除</title><children><topics type="attached"><topic id="74mfbn91accll8eu9aksmmli4g" modified-by="" timestamp="1512439325923"><title>remove(Object obj)</title><children><topics type="attached"><topic id="05mui9p3vl34igkqpko2rk6juv" modified-by="" timestamp="1512439336776"><title>删除一个元素</title></topic></topics></children></topic><topic id="7ikavn4guui6jn9nu69or15jgb" modified-by="" timestamp="1512439339154"><title>removeAll(Collection other)</title><children><topics type="attached"><topic id="2c2f5qlk63dc5fl0ih9tps7run" modified-by="" timestamp="1512439353649"><title>从当前集合中删除它俩的交集</title><children><topics type="attached"><topic id="0m8na27nsisglspt35t13oukto" modified-by="" timestamp="1512439363263"><title>this -  this ∩ other</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="1lmal37p06thmrvmcjacf8njhn" modified-by="" timestamp="1512439380354"><title>（3）查找</title><children><topics type="attached"><topic id="3nsgl6m2os93onhl64fgk86kqe" modified-by="" timestamp="1512439382292"><title>contains(Object obj)</title><children><topics type="attached"><topic id="55h0fpsgc8issoicf1tlbi7uuu" modified-by="" timestamp="1512439393521"><title>在当前集合中查找一个元素</title></topic></topics></children></topic><topic id="5teb0vn40rahh91gb3fs3b6rvl" modified-by="" timestamp="1512439394865"><title>containsAll(Collection c)</title><children><topics type="attached"><topic id="6pf2vqrfqt0fbucfu55loc1p4q" modified-by="" timestamp="1512439413933"><title>判断c是否是当前集合的子集</title></topic></topics></children></topic></topics></children></topic><topic id="2equrq7sc97fjs8ivugpphaicr" modified-by="" timestamp="1512439476229"><title>（4）其他</title><children><topics type="attached"><topic id="5p2p2rtpqlg41pbn1s9kbvehqf" modified-by="" timestamp="1512439425714"><title>size()</title><children><topics type="attached"><topic id="2tkm9ir325n2k9hv7e79as458n" modified-by="" timestamp="1512439431549"><title>获取有效元素的个数</title></topic></topics></children></topic><topic id="6q6aiumpggdlvefc31627k5o7j" modified-by="" timestamp="1512439453165"><title>retainsAll(Collection other)</title><children><topics type="attached"><topic id="65sdivcib8dbh98hqv67bj3o5c" modified-by="" timestamp="1512439465240"><title>把this ∩ other赋值给当前集合</title><children><topics type="attached"><topic id="5je8r27oc05dmthaij13k7p0u8" modified-by="" timestamp="1512439469176"><title>this =  this ∩ other</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="201r1h5pg5ffb31hrq7jhappjm" modified-by="" timestamp="1512439495468"><title>（5）遍历</title><children><topics type="attached"><topic id="211tv8oml3jlq15h4j42n55gir" modified-by="" timestamp="1512439490501"><title>Iterator iterator()</title></topic><topic id="1src9rv3s0v8omg6matvplvpb6" modified-by="" timestamp="1512439496660"><title>Object[] toArray()</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="02n1vtsp75rroogqkt5ojsk6mc" modified-by="" timestamp="1512525799827"><title>Map</title><children><topics type="attached"><topic id="6g6fb77sr1o2qguoktgdj920jr" modified-by="" timestamp="1512525728381"><title>Map的特点</title><children><topics type="attached"><topic id="4h1127834h9sk1m5uq1vtki827" modified-by="" timestamp="1512525744055"><title svg:width="500">Map的元素，即存储的映射关系（key,value），其类型是Entry类型，它是Map的内部子接口，在各种Map的实现类中，都用内部类的方式来实现Entry接口</title></topic><topic id="0tgfmn4jgpmeruulvtkmjqb060" modified-by="" timestamp="1512525714042"><title svg:width="500">Map的key不可重复，而且一旦添加到map中，key不建议修改，特别是参与hashCode和equals方法的属性，或参与compareTo或compare方法比较的属性</title></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic><topic id="3di9old3vbc7aqgj636kai32ea" modified-by="" timestamp="1512525494059"><title>Map的常用方法</title></topic><topic id="1odr967fon3vihdphtd52crcha" modified-by="" timestamp="1512525608023"><title>Map的常见实现类</title><children><topics type="attached"><topic id="2fjg2vmetk1hl5j1ivvvposjhc" modified-by="" timestamp="1512525621745"><title>Hashtable</title><children><topics type="attached"><topic id="0iufvg18h4mjpl5vqt7r50ep50" modified-by="" timestamp="1512525621707"><title>JDK1.0就有的，属于旧版HashMap，线程安全的</title></topic></topics></children></topic><topic id="1m2i503tq69dmr85iuvvfbc6s7" modified-by="" timestamp="1512525631081"><title>HashMap</title><children><topics type="attached"><topic id="5eluj8ibodd01ae8k93i6ats6f" modified-by="" timestamp="1512525633103"><title svg:width="500">它的key不可重复的，依据key的hashCode()和equals()方法，线程不安全的&#13;
	JDK1.7时底层实现是数组+链表&#13;
	JDK1.8时底层实现是数组+链表+红黑树</title></topic></topics></children></topic><topic id="4fv418fh2p4cl28ufqs3g30g31" modified-by="" timestamp="1512525756660"><title>TreeMap</title><children><topics type="attached"><topic id="0ed04kh5eihl9glsa4baoaeada" modified-by="" timestamp="1512525758512"><title svg:width="500">它的key不可重复的，按照key的“大小”顺序进行排列,&#13;
	依据key的自然排序Comparable（compareTo())或定制排序Comparator(compare())规则进行排序</title></topic></topics></children></topic><topic id="5s3l9ibu6qofekdpipor7peh6m" modified-by="" timestamp="1512525764842"><title>LinkedHashMap</title><children><topics type="attached"><topic id="386fjc75u14t7hjn9c6f1o82le" modified-by="" timestamp="1512525772558"><title svg:width="500">它是HashMap的子类，在HashMap的基础上同时要维护添加的顺序</title></topic></topics></children></topic><topic id="3iako0s0p2ir1om7u7mjpp7m85" modified-by="" timestamp="1512525772882"><title>Properties</title><children><topics type="attached"><topic id="5ichsaq7unenqnittnf89p74qb" modified-by="" timestamp="1512525774570"><title svg:width="500">Properties是Hashtable的子类，它的key和value的类型都是String类型</title></topic></topics></children></topic></topics></children></topic><topic id="20e251b4sm4cta25qo7vnafrmq" modified-by="" timestamp="1512525842342"><title>高频面试题：HashMap的底层实现过程</title><children><topics type="attached"><topic id="2eeabmu77b4hh7slv8h4pthd6m" modified-by="" timestamp="1512525823959"><title svg:width="500">	JDK1.7时底层实现是数组+链表&#13;
		当我们要添加一个新的映射关系时，&#13;
		(1)先取出key，算出它的hash值&#13;
		(2)如果数组是空的，会先建立一个长度为16的数组table&#13;
		(3)如果数组不为空，这个时候要判断数组的长度是否达到临界点（数组长度*0.75），如果已经达到临界点，应该先对数组进行扩容，扩大为2倍&#13;
		一旦扩容，要重头开始（以前元素要重新排序位置，对新添加的映射关系也要重写计算key的hash值，和index）&#13;
		(4)会根据key的hash值与table数组的长度做一个“按位与&amp;”的运算，计算出要存储的下标index&#13;
		(5)先判断table[index]是否为空，如果为空，直接放进去，放进去之前会构建一个Entry类型对象&#13;
		(6)如果table[index]不是空的，那么调用key的equals方法与table[index]的key做比较，如果table[index]下面还有链表，&#13;
		可能需要与table[index]下面的链表的元素一一比较，直到遇到了equals为true或都不相同&#13;
		(7)如果有一个equals返回true，那么就把value给替换&#13;
		(8)如果equals都不相等，那么把当前映射关系构建的Entry对象，放在此链表的表头，把原来的对象作为我的next</title></topic><topic id="69t21g4cbk6ojfq5nqdgq2eprq" modified-by="" timestamp="1512525845205"><title svg:width="500">	JDK1.8时底层实现是数组+链表+红黑树&#13;
		当我们要添加一个新的映射关系时，&#13;
		(1)先取出key，算出它的hash值&#13;
		(2)如果数组是空的，会先建立一个长度为16的数组table&#13;
		(3)如果数组不为空，这个时候要判断数组的长度是否达到临界点（数组长度*0.75），如果已经达到临界点，应该先对数组进行扩容，扩大为2倍&#13;
		一旦扩容，要重头开始（以前元素要重新排序位置，对新添加的映射关系也要重写计算key的hash值，和index）&#13;
		(4)会根据key的hash值与table数组的长度做一个“按位与&amp;”的运算，计算出要存储的下标index&#13;
		(5)先判断table[index]是否为空，如果为空，直接放进去，放进去之前会构建一个Entry类型对象&#13;
		(6)如果table[index]不是空的，那么调用key的equals方法与table[index]的key做比较，如果table[index]下面有树或者链表，&#13;
		可能需要与table[index]下面的链表或树的元素一一比较，直到遇到了equals为true或都不相同&#13;
		(7)如果有一个equals返回true，那么就把value给替换&#13;
		(8)如果都不相等，如果现在已经是树，就直接添加到该树的叶子节点上。&#13;
		(9)如果都不相等，如果现在不是树，而是链表，看当前链表的长度是否达到8个，如果没有达到8个，直接添加到链表的尾部&#13;
		(10)如果已经达到8个，此时要检查数组table的长度是否达到64，如果没有达到64，先扩容，一旦扩容，一切从头开始&#13;
		(11)如果达到64，把该链表变成一颗红黑树&#13;
		&#13;
		什么时候树会变回链表？&#13;
		每次进行resize()，会检查树的叶子节点的总数是否&lt;6个，如果&lt;6个，会把这个红黑树变回链表</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>集合</title></sheet></xmap-revision-content>