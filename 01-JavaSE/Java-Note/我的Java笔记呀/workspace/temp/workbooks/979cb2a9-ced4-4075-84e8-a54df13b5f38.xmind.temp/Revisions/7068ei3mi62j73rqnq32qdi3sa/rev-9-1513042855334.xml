<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="7068ei3mi62j73rqnq32qdi3sa" modified-by="" style-id="0kstj9p5njfq9famsfnsd1bk44" theme="xminddefaultthemeid" timestamp="1513042853434"><topic id="7ahcc0rkuhkv2avc0ktoru1mph" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1513042406204"><title>反射机制</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="75ap3focngkct538ucqm7flpn0" modified-by="" timestamp="1513039339241"><title>为什么要用反射？</title><children><topics type="attached"><topic id="4sdlu9vs868bknpakf5vpma8iv" modified-by="" timestamp="1513039405682"><title svg:width="500">因为Java是静态的强类型语言，在编译阶段就需要确定类型</title><children><topics type="attached"><topic id="2hhourjhfkc9fgknavinhevfsu" modified-by="" timestamp="1513039842426"><title>Java为了实现“动态性“特征，引入了反射机制</title><children><topics type="attached"><topic id="0j6j7m3ida2jhtaj867u2toir1" modified-by="" timestamp="1513039489365"><title svg:width="500">变量可以使用Object声明，然后在运行时确定某个对象的运行时类型</title></topic><topic id="299qhflgqs8p0h6jdsuso98t3u" modified-by="" timestamp="1513039526843"><title svg:width="500">或者在运行时动态的”注入“某个类型的对象，动态的创建某个类型的对象</title><children><topics type="attached"><topic id="0rqdo3o0n1b1ht9vq756ijc4lc" modified-by="" timestamp="1513039540571"><title svg:width="500">例如：用这个类型的Class对象，然后创建它的实例</title></topic></topics></children></topic><topic id="3ba2b56nru91htu1pgp3p2moo1" modified-by="" timestamp="1513039847191"><title>。。。。</title></topic></topics></children></topic></topics></children></topic><topic id="5kb0310eu1487vots4ffu5aici" modified-by="" timestamp="1513039373516"><title svg:width="500">例如：JS等是动态的弱类型的语言，在运行时确定变量的类型，根据赋的值确定变量的类型</title></topic></topics></children></topic><topic id="7c39fhkbkffiien8r2thkfvpci" modified-by="" timestamp="1513040148085"><title>反射的根源</title><children><topics type="attached"><topic id="0pap2qm32f8964e1k2a682ttk9" modified-by="" timestamp="1513039901216"><title>java.lang.Class</title><children><topics type="attached"><topic id="4fk691plab5a9mkj2i050fpjul" modified-by="" timestamp="1513039968687"><title svg:width="500">Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。 </title><children><topics type="attached"><topic id="6u5rnpu2etvcna9pnc02bt805k" modified-by="" timestamp="1513040025766"><title>示例代码</title><children><topics type="attached"><topic id="14254lghnq3papk9dinbpbqrbc" modified-by="" timestamp="1513040027802"><title svg:width="500">	@Test&#13;
	public void test() {&#13;
		Class c1 = int.class;&#13;
		Class c2 = void.class;&#13;
		Class c3 = String.class;&#13;
		Class c4 = Comparable.class;&#13;
		Class c5 = ElementType.class;&#13;
		Class c6 = Override.class;&#13;
		Class c7 = int[].class;&#13;
		&#13;
		int[] arr1 = new int[5];&#13;
		int[] arr2 = new int[10];&#13;
		&#13;
		System.out.println(arr1.getClass() == arr2.getClass());&#13;
		System.out.println(int[].class == arr2.getClass());&#13;
		&#13;
		int[][] arr3 = new int[5][10];&#13;
		System.out.println(arr1.getClass());&#13;
		System.out.println(arr3.getClass());&#13;
	}</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0tldv37hoijg0donmd5bm1v9lk" modified-by="" timestamp="1513040293963"><title>四种获取Class对象的方式</title><children><topics type="attached"><topic id="4nuo1ov94ss3skv10uf9253cn2" modified-by="" timestamp="1513040177875"><title>（1）如果类型已知：</title><children><topics type="attached"><topic id="6nv65q8432u5es9abs4ognurph" modified-by="" timestamp="1513040196830"><title>类型名.class</title></topic></topics></children></topic><topic id="06n9d2tnkrshi85uq6n53c3ijd" modified-by="" timestamp="1513040226757"><title>（2）如果对象存在</title><children><topics type="attached"><topic id="37hiqo54hj1auh31qv8g3mme9l" modified-by="" timestamp="1513040233118"><title>对象.getClass()</title></topic></topics></children></topic><topic id="5pqnq8hr0ojruk38rclntepd8v" modified-by="" timestamp="1513040276796"><title svg:width="500">（3）如果在编译阶段未知，但是运行阶段可以获取它的类型全名称</title><children><topics type="attached"><topic id="6vrfjvdhmsq7pn2l3qlvn9qf6o" modified-by="" timestamp="1513040289312"><title>Class.forName("类型全名称")</title></topic></topics></children></topic><topic id="4vevq5f7ctvbp66g57guboe6v4" modified-by="" timestamp="1513040297402"><title svg:width="500">（4）如果在编译阶段未知，但是运行阶段可以获取它的类型全名称</title><children><topics type="attached"><topic id="4b0cigc8le7925k8hlpqgr12v5" modified-by="" timestamp="1513040308123"><title>类加载对象.loadClass("类型全名称")</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="5brc2s5m70clnb00pqml2u3c7j" modified-by="" timestamp="1513040380340"><title>相关的API（了解）</title><children><topics type="attached"><topic id="0di5flmtn0mj5ds0ls36dfnu36" modified-by="" timestamp="1513040460333"><title>java.lang.Class</title><children><topics type="attached"><topic id="52vv6dvrc7avde7fsaig7uljvt" modified-by="" timestamp="1513041184557"><title>方法</title><children><topics type="attached"><topic id="2169d5qkg33q0203o35qe4gdqo" modified-by="" timestamp="1513040482014"><title>（1）获取类型名：</title><children><topics type="attached"><topic id="5pdl6a2a34m79mhmhs4feaar3q" modified-by="" timestamp="1513040485319"><title>getName()</title></topic></topics></children></topic><topic id="121ivu1m3jlf3db0926oajdg9q" modified-by="" timestamp="1513040506621"><title>（2）创建实例对象</title><children><topics type="attached"><topic id="7bvouss179i1l63lgdcu5rd7fa" modified-by="" timestamp="1513041455302"><title>newInstance()</title><children><topics type="attached"><topic id="7s8m5h7n3p3t0amnvdjbnjjfup" modified-by="" timestamp="1513040524158"><title>这个类型必须有无参构造</title></topic><topic id="2kinf7o45mfldjkli3agkoji88" modified-by="" timestamp="1513041467670"><title>Class对象.newInstance()</title></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic><topic id="4g5ffurh9v01io4k749flc8f55" modified-by="" timestamp="1513040542752"><title>（3）获取包的信息</title><children><topics type="attached"><topic id="0ak9sfsqpd0akedtoo7mil5m1s" modified-by="" timestamp="1513040553048"><title>getPackage()</title></topic></topics></children></topic><topic id="63mbgfujlp968fsb00t4ti7sgo" modified-by="" timestamp="1513041288435"><title>（4）获取父类</title><children><topics type="attached"><topic id="72ftq5u3026rqdjupnpsbmrpt4" modified-by="" timestamp="1513040624379"><title>Class  getSuperClass()</title><children><topics type="attached"><topic id="5gr5thgvemka3grho3la06vsfv" modified-by="" timestamp="1513040618901"><title>不带泛型</title></topic></topics></children></topic><topic id="2o4c38nler142k42lgevq84tde" modified-by="" timestamp="1513040646607"><title>Type  getGenericSuperClass()</title><children><topics type="attached"><topic id="5onsk80rnlftlaau6hgi4s99l9" modified-by="" timestamp="1513040651852"><title>可以带泛型</title></topic></topics></children></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic><topic id="5qehdlvnv0lfie39igff7lsjuk" modified-by="" timestamp="1513040737847"><title>（5）获取父接口</title><children><topics type="attached"><topic id="19hnlnaunk5erq4eat1723rq8s" modified-by="" timestamp="1513040841717"><title>Class[]  getInterfaces()</title><children><topics type="attached"><topic id="3m68lc01milt9uq520ceul9m92" modified-by="" timestamp="1513040693019"><title>不带泛型</title></topic></topics></children></topic><topic id="4ik1nlmmc2bbsu5gc62d820bk0" modified-by="" timestamp="1513040744642"><title>Type[]  getGenericInterfaces()</title><children><topics type="attached"><topic id="1bopig65rtrouo8ngko30p65m8" modified-by="" timestamp="1513040747358"><title>可以带泛型</title></topic></topics></children></topic></topics></children></topic><topic id="09hosl8h60j7ibr7tm2at8pku1" modified-by="" timestamp="1513040899929"><title>（6）获取该类型的属性</title><children><topics type="attached"><topic id="5rr96966idkdmqarrqlctkt83r" modified-by="" timestamp="1513040801873"><title>获取全部可访问的公共的属性</title><children><topics type="attached"><topic id="3i32d8m78ueebg7b5ldr7jdcqv" modified-by="" timestamp="1513040834117"><title>Field[]   getFields()</title></topic></topics></children></topic><topic id="1ch6i34r7apbj17i8fdg02dlqp" modified-by="" timestamp="1513040816178"><title>获取全部已声明的属性</title><children><topics type="attached"><topic id="0klvf9km2a2um8in1bg05kaccv" modified-by="" timestamp="1513040845389"><title>Field[]  getDeclaredFields()</title></topic></topics></children></topic><topic id="18f4hd6eghsq0dbl1enjbidjk2" modified-by="" timestamp="1513040860015"><title>获取某一个公共的属性</title><children><topics type="attached"><topic id="0s2pmjt07ggu2ajo4a3khn7j6r" modified-by="" timestamp="1513040890117"><title>Field  getField("属性名")</title></topic></topics></children></topic><topic id="3ti755a2doo2oreii1h7vp1ahs" modified-by="" timestamp="1513041295282"><title>获取某一个声明过的属性，可能是私有的等</title><children><topics type="attached"><topic id="114ldrmncqelidn8ssc1qhe17e" modified-by="" timestamp="1513040923105"><title>Field  getDeclaredField("属性名")</title></topic><topic id="77cc5pu3ad1lvjg0u6n7l00mca" modified-by="" timestamp="1513041154549"><title>通过属性名就可以唯一确定一个属性</title></topic></topics></children><marker-refs><marker-ref marker-id="flag-red"/></marker-refs></topic></topics></children></topic><topic id="1bcfn17456el95ecatn8a6994l" modified-by="" timestamp="1513040989200"><title>（7）获取该类的构造器</title><children><topics type="attached"><topic id="20nrbho351kgogdp77n403is5k" modified-by="" timestamp="1513040964494"><title>获取全部的公共的构造器</title></topic><topic id="6ks31gbmpo2d22hg9svghkdra3" modified-by="" timestamp="1513040977284"><title>获取全部已声明的构造器</title></topic><topic id="2o1iln24prr4v2b08qttb17ca8" modified-by="" timestamp="1513040988326"><title>获取某一个公共的构造器</title></topic><topic id="4qcpaburiumkooodav0kb4gnro" modified-by="" timestamp="1513041155417"><title>获取某一个已声明的构造器</title><children><topics type="attached"><topic id="4412kfjj6han6n9rf8e9cfjj08" modified-by="" timestamp="1513041055562"><title svg:width="500">Constructor  getDeclaredConstructor(形参列表的类型Class列表...  )</title></topic><topic id="1m8vc8399ucu83hns871c4e0hk" modified-by="" timestamp="1513041170131"><title>通过构造器的形参列表就可以唯一确定一个构造器</title></topic></topics></children></topic></topics></children></topic><topic id="52k52u66g9fkf802ucvnbkb38o" modified-by="" timestamp="1513041079038"><title>（8）获取该类的方法</title><children><topics type="attached"><topic id="333mkoqbqa0htcrkjc5isnjt6m" modified-by="" timestamp="1513041084102"><title>获取全部的公共的方法</title></topic><topic id="34vhkpdl1g268pkl1u0e07m0b7" modified-by="" timestamp="1513041087367"><title>获取全部已声明的方法</title></topic><topic id="0g7d8010fbhjo8a5pjl5pjbasg" modified-by="" timestamp="1513041090724"><title>获取某一个公共的方法</title></topic><topic id="4ud4mmhk98r8mltp5ejv3dnf7v" modified-by="" timestamp="1513041306457"><title>获取某一个已声明的方法</title><children><topics type="attached"><topic id="5ru183eb5e9suncljqoodsa59k" modified-by="" timestamp="1513041137099"><title svg:width="500">Method getDeclaredMethod("方法名", 形参列表的类型Class列表 ....)</title></topic><topic id="15hqqsipjq0t9g2d7kfbs0kin4" modified-by="" timestamp="1513041180484"><title svg:width="500">通过方法的名称+形参列表才能唯一确定一个方法</title></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic></topics></children></topic><topic id="5d9dtugk1kub0c1um2n751hgen" modified-by="" timestamp="1513041235049"><title>（9）获取类上的注解</title><children><topics type="attached"><topic id="530vnk70ggl6vktintj3poeh1l" modified-by="" timestamp="1513041226901"><title>获取所有的注解/注释</title><children><topics type="attached"><topic id="31grmbg4rs2nfms881n6o70573" modified-by="" timestamp="1513041233776"><title> Annotation[] getAnnotations() </title></topic></topics></children></topic><topic id="56spgfu8hvfv7554971m49sanp" modified-by="" timestamp="1513041309447"><title>获取指定的注解</title><children><topics type="attached"><topic id="5q74vpqassi446934ddn0r23ai" modified-by="" timestamp="1513041276776"><title svg:width="500">&lt;A extends Annotation&gt;  A   getAnnotation(Class&lt;A&gt; annotationClass) </title></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="190p8gf0l2622g3haf0551gfum" modified-by="" timestamp="1513040455894"><title>java.lang.reflect</title><children><topics type="attached"><topic id="13k4rippcvn7l8c46nnnl6ttd1" modified-by="" timestamp="1513041323066"><title>Package</title><children><topics type="attached"><topic id="5uu3ou8mh8d0cta9qeo4l7unue" modified-by="" timestamp="1513041330811"><title>获取包名</title><children><topics type="attached"><topic id="55155lbr6j2a28hombpdqg43re" modified-by="" timestamp="1513041336391"><title>getName()</title></topic></topics></children></topic></topics></children></topic><topic id="3hfivgo3vu0udh9m2uggs2tefk" modified-by="" timestamp="1513041349980"><title>Modifier</title><children><topics type="attached"><topic id="1nob34obshqsnl5j3vct30uola" modified-by="" timestamp="1513041362020"><title>Modifier.toString(mod)</title></topic></topics></children></topic><topic id="5u66ebm1uaq8b1amin055nue6h" modified-by="" timestamp="1513041370454"><title>Constructor</title><children><topics type="attached"><topic id="2thvt7paisu28m6tjrsp2aae5h" modified-by="" timestamp="1513041378725"><title>创建实例对象</title><children><topics type="attached"><topic id="3d7jp6fvleqop9hs17vmdg97kv" modified-by="" timestamp="1513041427654"><title>newInstance(Object ...)</title><children><topics type="attached"><topic id="108u1g9t6f0mde52ek7voejlsm" modified-by="" timestamp="1513041426614"><title svg:width="500">如果无参，那么就直接“构造器对象.newInstance()”</title></topic><topic id="5l8dvsfs7383eh6p7ki5supe2g" modified-by="" timestamp="1513041448578"><title svg:width="500">如果有参：构造器对象.newInstance(给构造器的实参列表)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0gtt4bjgqgosp7ad5gp860h68i" modified-by="" timestamp="1513041518349"><title>Field</title><children><topics type="attached"><topic id="4rl2lk5r2itjds55atq3qhspeq" modified-by="" timestamp="1513041508939"><title>（1）setAccessible(true)</title></topic><topic id="15amdst3jjs8252c793cn7bbh4" modified-by="" timestamp="1513041562629"><title>（2）Object  get(实例对象)</title><children><topics type="attached"><topic id="51iuu1mfmvc67tkrb43vfb9g39" modified-by="" timestamp="1513041561777"><title>Object  属性对象.get(实例对象)</title></topic><topic id="4jd74f24ihv8c848knb05pra2d" modified-by="" timestamp="1513041579713"><title>原来是：  实例对象.get属性名();</title></topic></topics></children></topic><topic id="6r54il63nn7vu5lrvqot98hunr" modified-by="" timestamp="1513041634748"><title>（3）set(实例对象， 属性的新值)</title><children><topics type="attached"><topic id="0ge3lcu9ae7cnfpvvkur3nrs7k" modified-by="" timestamp="1513041633679"><title>属性对象.set（实例对象，属性值）</title></topic><topic id="1m3enfh5o259mbbn5a0k8l9ejo" modified-by="" timestamp="1513041646995"><title>原来是：实例对象.set属性名（属性值）</title></topic></topics></children></topic></topics></children></topic><topic id="1c7b917e985mvaks5rs3ia17ul" modified-by="" timestamp="1513041699537"><title>Method</title><children><topics type="attached"><topic id="6v5127n9p7slquk85fdc4guubl" modified-by="" timestamp="1513041689906"><title>（1）setAccessible(true)</title><children><topics type="attached"><topic id="7q8nevv4bvjvd7rnmu895v9el3" modified-by="" timestamp="1513041698203"><title>如果方法不是public才需要</title></topic></topics></children></topic><topic id="1lf9imhqofoba45aik7end2msp" modified-by="" timestamp="1513041797797"><title svg:width="500">（2）Object invoke(实例对象, 传给被调用方法的实参列表)</title><children><topics type="attached"><topic id="3gij4vfcnh9lfcb96j1ubl2224" modified-by="" timestamp="1513041857208"><title svg:width="500">Object  returnValue = 方法对象.invoke(实例对象，实参列表...）</title><children><topics type="attached"><topic id="3hrpg8erbfp1f84lfga0qso31r" modified-by="" timestamp="1513041794376"><title svg:width="500">如果原来的方法对象是没有返回值，即是void，那么returnValue是null</title></topic></topics></children></topic><topic id="0b7m1lh08c6uhaggb5irrp0vdk" modified-by="" timestamp="1513041837919"><title>原来：</title><children><topics type="attached"><topic id="3slqfffgpd0gahvaqj5svd65ac" modified-by="" timestamp="1513041841743"><title>有返回值</title><children><topics type="attached"><topic id="01rlnv5finbhapqmt5704rtifq" modified-by="" timestamp="1513041843265"><title>变量 = 实例对象.方法名(实参列表)</title></topic></topics></children></topic><topic id="0npetnujpn5lfcpep2hp9itj2c" modified-by="" timestamp="1513041847205"><title>无返回值</title><children><topics type="attached"><topic id="4j7a4ss9npr5s5khrrhf9ui61i" modified-by="" timestamp="1513041850601"><title>实例对象.方法名(实参列表);</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="6rshg0ehu82f2sj7o57tk0fpo6" modified-by="" timestamp="1513042236646"><title>如何获取类上的泛型</title><children><topics type="attached"><topic id="6sf3bd3dcud0us8gaan0quuvtl" modified-by="" timestamp="1513042200507"><title>步骤</title><children><topics type="attached"><topic id="49023vmkfpmsrepo95odouum69" modified-by="" timestamp="1513042087731"><title>（1）先得到类的Class对象</title></topic><topic id="6u6c4pha22d844aig330kj4jgp" modified-by="" timestamp="1513042126194"><title>（2）获取它的父类</title><children><topics type="attached"><topic id="0ok14a57d967jiaea7gpriekud" modified-by="" timestamp="1513042131541"><title>Type  getGenericSuperClass() 可以带泛型</title></topic></topics></children></topic><topic id="37pvjcd0bd6hbsrnspf64sdi45" modified-by="" timestamp="1513042174979"><title>（3）类型转换</title><children><topics type="attached"><topic id="0lda0ssukj2u6uv88b6u6uoke7" modified-by="" timestamp="1513042172410"><title>如果是父类是这样的类型    父类名&lt;泛型实参&gt;</title></topic><topic id="0p3bp0c6tk97p4unc45v768c5s" modified-by="" timestamp="1513042198444"><title svg:width="500">ParameterizedType  p = (ParameterizedType )type;</title></topic></topics></children></topic><topic id="1p1vr8ahteuflspnufslmvsgsk" modified-by="" timestamp="1513042208408"><title>（4）获取泛型实参</title><children><topics type="attached"><topic id="5dsl0ba1hjdh8pvq70th7isp8t" modified-by="" timestamp="1513042223738"><title>Type[] getActualTypeArguments()  </title></topic></topics></children></topic></topics></children></topic><topic id="02qe28775q6uvu8ubcfdc5osu5" modified-by="" timestamp="1513042242009"><title>示例代码</title></topic></topics></children></topic><topic id="217nb63lpmda0lkfha7fc4vnjs" modified-by="" timestamp="1513042371502"><title>获取注解</title><children><topics type="attached"><topic id="2g427s5a8mo4bmc1sfhd2mvtag" modified-by="" timestamp="1513042267774"><title>获取类上的注解</title><children><topics type="attached"><topic id="4nsksd5tbe4465r9t2l4lsffli" modified-by="" timestamp="1513042286670"><title>步骤</title><children><topics type="attached"><topic id="65pqiupmsuuk412fravjop3mfo" modified-by="" timestamp="1513042272296"><title>（1）先得到类的Class对象</title></topic><topic id="3gbufgc2h3lenu5ohn4f4has5s" modified-by="" timestamp="1513042282272"><title>（2）</title><children><topics type="attached"><topic id="04ud19gcgcvlkt478nuedi2cc5" modified-by="" timestamp="1513042301443"><title>获取指定的注解</title><children><topics type="attached"><topic id="1sf9543gkn3gpufsfvfu8covn0" modified-by="" timestamp="1513041276776"><title svg:width="500">&lt;A extends Annotation&gt;  A   getAnnotation(Class&lt;A&gt; annotationClass) </title></topic><topic id="3rs0f04mv8tlkohklfaqbcj61s" modified-by="" timestamp="1513042316638"><title>可以获取到的注解，必须声明周期是RUNTIME</title></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic></topics></children></topic><topic id="5j7rcghvgiac4rkei3lv8modh9" modified-by="" timestamp="1513042296298"><title>（3）获取注解的配置参数的值</title></topic></topics></children></topic></topics></children></topic><topic id="32qit3u7bb5bmna6gq5b22kn81" modified-by="" timestamp="1513042334831"><title>获取属性上的注解</title><children><topics type="attached"><topic id="1h12v8d4e3t9sacforgonhqqn8" modified-by="" timestamp="1513042348838"><title>步骤</title><children><topics type="attached"><topic id="4oshv9n0k2kvdfoc6iskirastc" modified-by="" timestamp="1513042272296"><title>（1）先得到类的Class对象</title></topic><topic id="7kbejp1euuvasro4us46tak5d7" modified-by="" timestamp="1513042348820"><title>（2）获取属性对象</title></topic><topic id="6uvdh8oemq38i8rlerqfealrsf" modified-by="" timestamp="1513042353126"><title>（3）</title><children><topics type="attached"><topic id="6gfneim0utaa7nujlav0df7gbf" modified-by="" timestamp="1513042301443"><title>获取指定的注解</title><children><topics type="attached"><topic id="1evsdavjptq99db6k3t3ndlolh" modified-by="" timestamp="1513041276776"><title svg:width="500">&lt;A extends Annotation&gt;  A   getAnnotation(Class&lt;A&gt; annotationClass) </title></topic><topic id="4flpo5mhtdjrev0c5fofhvopbe" modified-by="" timestamp="1513042316638"><title>可以获取到的注解，必须声明周期是RUNTIME</title></topic></topics></children><marker-refs><marker-ref marker-id="star-red"/></marker-refs></topic></topics></children></topic><topic id="41ee7m48rk5tq5gb15ghptbnge" modified-by="" timestamp="1513042357060"><title>（4）获取注解的配置参数的值</title></topic></topics></children></topic></topics></children></topic><topic id="15e7enpk9ldpvisupk4vkokd3f" modified-by="" timestamp="1513042374581"><title>示例代码</title></topic></topics></children></topic><topic id="6d1v0i6j0rrv1tcpd9r9tniab7" modified-by="" timestamp="1513042605124"><title>类加载器</title><children><topics type="attached"><topic id="56lhe11cjgq7e43ntabmqeop0r" modified-by="" timestamp="1513042430247"><title>类加载的过程（了解）</title><children><topics type="attached"><topic id="14hr2h7sng1u7ajgegebc7tqge" modified-by="" timestamp="1513042462323"><title>双亲委托模式/机制</title><children><topics type="attached"><topic id="1mtnhimg84utv8qio965mmdel5" modified-by="" timestamp="1513042589433"><title svg:width="500">某个类加载器接到加载任务，先把加载任务交给“父”加载器，层层往上，一直到引导类加载器，如果“父”加载器可以加载，那么就由“父”加载器加载，如果不可以，传回它的“子”加载器，“子”加载器尝试加载，如果可以，那么就加载，如果不可以，再往回传，一到回到最初接到任务的那个加载器，如果它可以，也正常加载，如果它也不能加载，报异常：ClassNotFoundException</title></topic></topics></children></topic></topics></children></topic><topic id="7fuo8rdpmaq5ffmcr1t8p2vpug" modified-by="" timestamp="1513042831926"><title>类加载器的体系结构</title><children><topics type="attached"><topic id="39ohr52kk1fgv12fs2qp88t6e1" modified-by="" timestamp="1513042669427"><title>1、引导类加载器BootStrap</title><children><topics type="attached"><topic id="75dgv40ssho13c05n8837sa06t" modified-by="" timestamp="1513042640034"><title>非Java语言实现的</title><children><topics type="attached"><topic id="1niov8aif59s2t6qs3ih5km898" modified-by="" timestamp="1513042650167"><title>获取不到它的对象，只能得到null</title></topic></topics></children></topic><topic id="304ukjle2ehb52v8rv6fjaamjj" modified-by="" timestamp="1513042664085"><title>加载核心类库rt.jar</title></topic><topic id="3s05ip980oi64lp4qvha0bf63t" modified-by="" timestamp="1513042711505"><title>加载sun.boot.class.path路径下的内容</title></topic></topics></children></topic><topic id="6usavbeaglr8rk85natkiubcql" modified-by="" timestamp="1513042776598"><title>2、扩展类加载器ExtClassLoader</title><children><topics type="attached"><topic id="3pr2h7gpdtmgt3ist79f3t5hj0" modified-by="" timestamp="1513042766336"><title>加载jre/ext目录</title></topic><topic id="41s6o3841m956jpp9sg4macts5" modified-by="" timestamp="1513042780704"><title>java.ext.dirs路径下的内容</title></topic></topics></children></topic><topic id="2hl62m9eadob4nng83q0kgb7h9" modified-by="" timestamp="1513042812797"><title svg:width="500">3、应用程序类加载器，系统类加载器AppClassLoader</title><children><topics type="attached"><topic id="4ffet2q1m8q08hm0gejg8473k0" modified-by="" timestamp="1513042807067"><title>加载用户自定义的类型</title></topic><topic id="4dqqms4kkaosr3ged2o1j73pav" modified-by="" timestamp="1513042826938"><title>加载src目录下的内容（bin）</title></topic></topics></children></topic><topic id="7i7tcd4urtek6iic2lpjckeed6" modified-by="" timestamp="1513042853434"><title>4、自定义类加载器</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>画布 15</title></sheet></xmap-revision-content>