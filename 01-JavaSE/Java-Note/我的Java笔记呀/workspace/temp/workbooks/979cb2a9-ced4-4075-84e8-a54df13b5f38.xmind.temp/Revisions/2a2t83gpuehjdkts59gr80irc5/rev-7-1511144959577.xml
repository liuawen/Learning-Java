<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="2a2t83gpuehjdkts59gr80irc5" modified-by="" style-id="1pkvsjgemjhomahhj6p9o7gp4f" theme="xminddefaultthemeid" timestamp="1511144958357"><topic id="03re993mbt43s5uaer8m06ghoe" modified-by="" structure-class="org.xmind.ui.logic.right" timestamp="1511142111862"><title>数组</title><extensions><extension provider="org.xmind.ui.map.unbalanced"><content><right-number>-1</right-number></content></extension></extensions><children><topics type="attached"><topic id="5pluln4jse3u848o6c3f6ulcm3" modified-by="" timestamp="1511141557489"><title>数组的概念</title><children><topics type="attached"><topic id="707ri3m70u4eledim9nm6f42qt" modified-by="" timestamp="1511141538481"><title>数组的作用</title><children><topics type="attached"><topic id="3hqbbpgljpvl7bdaghd3n730lo" modified-by="" timestamp="1511141552130"><title>用来保存、管理一组相同数据类型的数据</title></topic></topics></children></topic><topic id="49mgb5eetma5qsfk5lvoq210em" modified-by="" timestamp="1511141680789"><title svg:width="500">把一组具有相同数据类型的变量使用同一个名字来进行管理，并且这些元素按照一定的顺序进行排列。这同一个名字我们称为【数组名】，每一个元素通过编号进行区别，这个编号我们称为【下标】或索引。元素的总个数就是【数组的长度】。</title></topic></topics></children></topic><topic id="3aq1tv5ruqon3an6l7ee6i2h44" modified-by="" timestamp="1511141744553"><title>数组如何声明和初始化</title><children><topics type="attached"><topic id="716mjrlrdssnf3o27le0k74i13" modified-by="" timestamp="1511141720314"><title>数组的声明</title><children><topics type="attached"><topic id="6cpnteo89n8oo7ngu0haqneb0j" modified-by="" timestamp="1511141709814"><title>数组的类型   数组名;</title></topic><topic id="6sub7hokid8tbvms5l5rph6cok" modified-by="" timestamp="1511141730098"><title>数组的元素的类型[]  数组名;</title><children><topics type="attached"><topic id="5hb83tl8e8c2cu5joe7g6hpqu0" modified-by="" timestamp="1511141735482"><title>推荐的方式</title></topic></topics></children></topic><topic id="4ra9jm1msi22k808ljka3coj3j" modified-by="" timestamp="1511141729370"><title>数组的元素的类型  数组名[];</title></topic></topics></children></topic><topic id="2qk1ubp1o2ba431n861u31kht4" modified-by="" timestamp="1511141753440"><title>初始化</title><children><topics type="attached"><topic id="5c1iahu9mf001s7kmfgn2v4nqb" modified-by="" timestamp="1511141758406"><title>动态初始化</title><children><topics type="attached"><topic id="4c478tr60joel6k2jk68b8hlio" modified-by="" timestamp="1511141803578"><title>格式：</title><children><topics type="attached"><topic id="7dlo75649cm75veptpfmla27dj" modified-by="" timestamp="1511141780096"><title>数组名 = new  元素的类型[数组的长度];</title></topic></topics></children></topic></topics></children></topic><topic id="0otsd7p9cr43s0ljfes1ujfg0v" modified-by="" timestamp="1511141805545"><title>静态初始化</title><children><topics type="attached"><topic id="73li4g8jif1e3tf4anpb5dvu3r" modified-by="" timestamp="1511141850802"><title>格式</title><children><topics type="attached"><topic id="21hrpdthrse1hnq80k4fu7q5o9" modified-by="" timestamp="1511141837012"><title>数组名 = new  元素的类型[]{元素列表};</title><children><topics type="attached"><topic id="1kogdm2d2pqjrc04j2qvd4c9u9" modified-by="" timestamp="1511141835604"><title>元素列表的每一个元素使用,分割</title></topic><topic id="0oerojrc5ju8sb8opikriohduq" modified-by="" timestamp="1511141843795"><title>元素列表的个数就是数组的长度</title></topic></topics></children></topic><topic id="3onesbec3rpdhbd8bgvjo6ogiu" modified-by="" timestamp="1511141856993"><title>简写形式</title><children><topics type="attached"><topic id="5u4ci9da12t489si5lt1c0ssmo" modified-by="" timestamp="1511141870864"><title>数组的元素的类型[]  数组名 = {元素列表};</title><children><topics type="attached"><topic id="7qdfpb8u0tu8e29tvnoqg0saap" modified-by="" timestamp="1511141890179"><title>只有声明和静态初始化在一行，才可以这么简写</title></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0pkk118jk2kob4tm7jt6mttllg" modified-by="" timestamp="1511141966700"><title>数组的元素</title><children><topics type="attached"><topic id="5jgdfcrllqrpmrnbm3gr6o3rnr" modified-by="" timestamp="1511141912614"><title>表示形式</title><children><topics type="attached"><topic id="7pqr4eopbntindt8gml9m4k858" modified-by="" timestamp="1511141919710"><title>数组名[下标]</title><children><topics type="attached"><topic id="38of3ka5fm6cm5sb9ggod34ai7" modified-by="" timestamp="1511141961699"><title>下标的范围</title><children><topics type="attached"><topic id="7vsqlhupmgftm5stdmjt3bg3u8" modified-by="" timestamp="1511141961720"><title>[0，数组的长度-1]</title><children><topics type="attached"><topic id="2p2gpberlhpekbtpo6bkshcf4o" modified-by="" timestamp="1511141961699"><title>[0,  数组名.length -1]</title></topic></topics></children></topic><topic id="5q1hkfgtg2q7gpa6de8q3tsd6m" modified-by="" timestamp="1511141948567"><title>[0，数组的长度)</title></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="5bumnkdr29dl42r0km3bpgunrg" modified-by="" timestamp="1511141975801"><title>赋值</title><children><topics type="attached"><topic id="449srsoikt8erdfbctq938ejk4" modified-by="" timestamp="1511141982630"><title>数组名[下标] = 值;</title></topic></topics></children></topic></topics></children></topic><topic id="6g2aqu3ask8gb1teco17f9qcd1" modified-by="" timestamp="1511142007898"><title>数组的长度</title><children><topics type="attached"><topic id="7vgh9qm6s1duuu9r5t9ivnt5hk" modified-by="" timestamp="1511142011938"><title>数组名.length</title></topic></topics></children></topic><topic id="4vrkqdpnu4348s88s3umvrcf6r" modified-by="" timestamp="1511142027689"><title>数组的遍历</title><children><topics type="attached"><topic id="12c0bg9rf3keunk0resg87ovcv" modified-by="" timestamp="1511142047670"><title>for循环</title><children><topics type="attached"><topic id="3bege1t8a9n82fqpsql6d5o7cn" modified-by="" timestamp="1511142069984"><title>for(int i=0; i&lt;数组名.length; i++){&#13;
}</title></topic></topics></children></topic><topic id="73plt2d7l7h94o3q33gselme7a" modified-by="" timestamp="1511142070935"><title>foreach循环</title><children><topics type="attached"><topic id="7fbcnl2cuquibtn2vjq7bfgal9" modified-by="" timestamp="1511142092888"><title>for(数组的元素的类型   元素的临时名 : 数组名){&#13;
}</title></topic></topics></children></topic></topics></children></topic><topic id="0n1lf6n70s8gdfo44d9qbk2gkr" modified-by="" timestamp="1511143110037"><title>数组的算法</title><children><topics type="attached"><topic id="5v0agm7tu4ugtd3amhmt22811r" modified-by="" timestamp="1511142250165"><title>（1）在数组中找最大值/最小值</title><notes><html><xhtml:p>	//找最大值</xhtml:p><xhtml:p>	public static int max(int[] arr){</xhtml:p><xhtml:p>		//第一步：假设第一个元素最大</xhtml:p><xhtml:p>		int max = arr[0];</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//遍历后面的元素和max比较</xhtml:p><xhtml:p>		for (int i = 1; i &lt; arr.length; i++) {</xhtml:p><xhtml:p>			//当有比max的值，就把max修改为它的值</xhtml:p><xhtml:p>			if(max &lt; arr[i]){</xhtml:p><xhtml:p>				max = arr[i];</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		return max;</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//找最大值&#13;
	public static int max(int[] arr){&#13;
		//第一步：假设第一个元素最大&#13;
		int max = arr[0];&#13;
		&#13;
		//遍历后面的元素和max比较&#13;
		for (int i = 1; i &lt; arr.length; i++) {&#13;
			//当有比max的值，就把max修改为它的值&#13;
			if(max &lt; arr[i]){&#13;
				max = arr[i];&#13;
			}&#13;
		}&#13;
		&#13;
		return max;&#13;
	}</plain></notes></topic><topic id="1li20b233k93uj5ampotj5306d" modified-by="" timestamp="1511142356681"><title>（2）在数组中找最大值、最小值的下标</title><notes><html><xhtml:p>	//找最大值的下标</xhtml:p><xhtml:p>	public static int maxIndex(int[] arr){</xhtml:p><xhtml:p>		//第一步：假设第一个元素最大</xhtml:p><xhtml:p>		int index = 0;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//arr[index] 和 后续的元素一一比较</xhtml:p><xhtml:p>		for (int i = 1; i &lt; arr.length; i++) {</xhtml:p><xhtml:p>			//当有比max的值，就把max修改为它的值</xhtml:p><xhtml:p>			if(arr[index] &lt; arr[i]){</xhtml:p><xhtml:p>				index = i;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		return index;</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//找最大值的下标&#13;
	public static int maxIndex(int[] arr){&#13;
		//第一步：假设第一个元素最大&#13;
		int index = 0;&#13;
		&#13;
		//arr[index] 和 后续的元素一一比较&#13;
		for (int i = 1; i &lt; arr.length; i++) {&#13;
			//当有比max的值，就把max修改为它的值&#13;
			if(arr[index] &lt; arr[i]){&#13;
				index = i;&#13;
			}&#13;
		}&#13;
		return index;&#13;
	}</plain></notes></topic><topic id="4t3k4jj79pulbtrdb6tc63in55" modified-by="" timestamp="1511142475019"><title>（3）数组元素的累加和，平均值</title><notes><html><xhtml:p>//求数组元素的总和</xhtml:p><xhtml:p>	public static long sum(int[] arr){</xhtml:p><xhtml:p>		long sum = 0;</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		for (int i = 0; i &lt; arr.length; i++) {</xhtml:p><xhtml:p>			sum += arr[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		return sum;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	public static double avg(int[] arr){</xhtml:p><xhtml:p>		double sum = sum(arr);</xhtml:p><xhtml:p>		return sum/arr.length;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/></html><plain>//求数组元素的总和&#13;
	public static long sum(int[] arr){&#13;
		long sum = 0;&#13;
		&#13;
		for (int i = 0; i &lt; arr.length; i++) {&#13;
			sum += arr[i];&#13;
		}&#13;
		&#13;
		return sum;&#13;
	}&#13;
	public static double avg(int[] arr){&#13;
		double sum = sum(arr);&#13;
		return sum/arr.length;&#13;
	}&#13;
</plain></notes></topic><topic id="15t8ga6qotnpm71u8h7sciats9" modified-by="" timestamp="1511142939404"><title>（4）反转</title><notes><html><xhtml:p>	//反转</xhtml:p><xhtml:p>	public static void reverse(int[] arr){</xhtml:p><xhtml:p>		//如果有5个元素，应该交换2次或3次      arr.length/2</xhtml:p><xhtml:p> 		//如果有6个元素，应该交换3次                 arr.length/2</xhtml:p><xhtml:p>		//数组的收尾对应位置交换</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//次数</xhtml:p><xhtml:p>		for(int i=0; i&lt;arr.length/2; i++){</xhtml:p><xhtml:p>			//首尾交换</xhtml:p><xhtml:p>			int temp = arr[i];</xhtml:p><xhtml:p>			arr[i] = arr[arr.length-1-i];</xhtml:p><xhtml:p>			arr[arr.length-1-i] = temp;</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p/><xhtml:p>	</xhtml:p><xhtml:p>	//反转部分</xhtml:p><xhtml:p>	public static void reverse(int[] arr, int start ,int end){</xhtml:p><xhtml:p>		//次数     </xhtml:p><xhtml:p>		//假设start = 1, end = 5     次数2次    (end + 1 - start)/2  (5+1-1)/2  2</xhtml:p><xhtml:p>		//假设start = 1, end = 6  次数3次      (end + 2 - start)/2  (6+1-1)/2  3</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		for(int i=0; i&lt; (end + 1 - start)/2; i++){</xhtml:p><xhtml:p>			//首尾交换</xhtml:p><xhtml:p>			//arr[start],arr[start+1]...</xhtml:p><xhtml:p>			//arr[end],arr[end-1]...</xhtml:p><xhtml:p>			int temp = arr[start + i];</xhtml:p><xhtml:p>			arr[start + i] = arr[end -i];</xhtml:p><xhtml:p>			arr[end-i] = temp;</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//反转&#13;
	public static void reverse(int[] arr){&#13;
		//如果有5个元素，应该交换2次或3次      arr.length/2&#13;
 		//如果有6个元素，应该交换3次                 arr.length/2&#13;
		//数组的收尾对应位置交换&#13;
		&#13;
		//次数&#13;
		for(int i=0; i&lt;arr.length/2; i++){&#13;
			//首尾交换&#13;
			int temp = arr[i];&#13;
			arr[i] = arr[arr.length-1-i];&#13;
			arr[arr.length-1-i] = temp;&#13;
		}&#13;
	}&#13;
&#13;
	&#13;
	//反转部分&#13;
	public static void reverse(int[] arr, int start ,int end){&#13;
		//次数     &#13;
		//假设start = 1, end = 5     次数2次    (end + 1 - start)/2  (5+1-1)/2  2&#13;
		//假设start = 1, end = 6  次数3次      (end + 2 - start)/2  (6+1-1)/2  3&#13;
		&#13;
		for(int i=0; i&lt; (end + 1 - start)/2; i++){&#13;
			//首尾交换&#13;
			//arr[start],arr[start+1]...&#13;
			//arr[end],arr[end-1]...&#13;
			int temp = arr[start + i];&#13;
			arr[start + i] = arr[end -i];&#13;
			arr[end-i] = temp;&#13;
		}&#13;
	}</plain></notes></topic><topic id="25hge0qc6kjbm50qdn95dvjh61" modified-by="" timestamp="1511143108011"><title>（5）复制</title><notes><html><xhtml:p>	//复制一个数组，从原数组的[0]元素开始复制，新数组的长度由使用者决定</xhtml:p><xhtml:p>	public static int[] copy(int[] src, int newLength){</xhtml:p><xhtml:p>		//1、创建新数组的对象</xhtml:p><xhtml:p>		int[] newArray = new int[newLength];</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、把原数组的元素复制到新数组中</xhtml:p><xhtml:p>		for(int i=0; i&lt;newArray.length &amp;&amp; i&lt;src.length; i++){</xhtml:p><xhtml:p>			newArray[i] = src[i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		return newArray;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//复制一个数组，从原数组的[start]元素开始复制，新数组的长度由使用者决定</xhtml:p><xhtml:p>	public static int[] copy(int[] src, int start, int newLength){</xhtml:p><xhtml:p>		//1、创建新数组</xhtml:p><xhtml:p>		int[] newArray = new int[newLength];</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		//2、把原数组的元素从[start]复制到新数组的[0]...</xhtml:p><xhtml:p>		for(int i=0; i&lt;newArray.length &amp;&amp; start+i&lt;src.length; i++){</xhtml:p><xhtml:p>			newArray[i] = src[start+i];</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>		</xhtml:p><xhtml:p>		return newArray;</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//复制一个数组，从原数组的[0]元素开始复制，新数组的长度由使用者决定&#13;
	public static int[] copy(int[] src, int newLength){&#13;
		//1、创建新数组的对象&#13;
		int[] newArray = new int[newLength];&#13;
		&#13;
		//2、把原数组的元素复制到新数组中&#13;
		for(int i=0; i&lt;newArray.length &amp;&amp; i&lt;src.length; i++){&#13;
			newArray[i] = src[i];&#13;
		}&#13;
		&#13;
		return newArray;&#13;
	}&#13;
	&#13;
	//复制一个数组，从原数组的[start]元素开始复制，新数组的长度由使用者决定&#13;
	public static int[] copy(int[] src, int start, int newLength){&#13;
		//1、创建新数组&#13;
		int[] newArray = new int[newLength];&#13;
		&#13;
		//2、把原数组的元素从[start]复制到新数组的[0]...&#13;
		for(int i=0; i&lt;newArray.length &amp;&amp; start+i&lt;src.length; i++){&#13;
			newArray[i] = src[start+i];&#13;
		}&#13;
		&#13;
		return newArray;&#13;
	}</plain></notes></topic><topic id="29mbi79kafe40cpo7mqbe6133e" modified-by="" timestamp="1511143124562"><title>（6）排序</title><children><topics type="attached"><topic id="0csuc5pksure782vh6upsfpi9s" modified-by="" timestamp="1511143189048"><title>冒泡排序</title><notes><html><xhtml:p>	//假设数组5个元素</xhtml:p><xhtml:p>	public static void pubSort3(int[] arr){</xhtml:p><xhtml:p>		//方式二：把大的往右沉</xhtml:p><xhtml:p>		//每一轮从左边开始比较</xhtml:p><xhtml:p>		//比较的轮数依然是n-1轮</xhtml:p><xhtml:p>		for(int i=1; i&lt;arr.length; i++){</xhtml:p><xhtml:p>			//每一轮从左边开始比较</xhtml:p><xhtml:p>			/*</xhtml:p><xhtml:p>			 * 第一轮：i=1， 比较4次，j=0,1,2,3   ,j&lt;arr.length-i  j&lt;5-1 j&lt;4 </xhtml:p><xhtml:p>			 * 第二轮：i=2，比较3次，j=0,1,2      ,j&lt;arr.length-i  j&lt;5-2 j&lt;3</xhtml:p><xhtml:p>			 * ...</xhtml:p><xhtml:p>			 */</xhtml:p><xhtml:p>			for(int j=0; j&lt;arr.length-i; j++){</xhtml:p><xhtml:p>				//如果左边的元比右边的元素大，交换</xhtml:p><xhtml:p>				if(arr[j] &gt; arr[j+1]){</xhtml:p><xhtml:p>					int temp = arr[j];</xhtml:p><xhtml:p>					arr[j] = arr[j+1];</xhtml:p><xhtml:p>					arr[j+1] = temp;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//假设数组5个元素</xhtml:p><xhtml:p>	public static void pubSort2(int[] arr){</xhtml:p><xhtml:p>		//排序规则：每一轮通过相邻元素的比较，把小的往左边冒（或把大的往右边沉），每一轮都是把本轮的最小值冒出来（最大值沉下去）</xhtml:p><xhtml:p>		//经过n-1轮完成最终的排序</xhtml:p><xhtml:p>		//(1)方式一：把小的往左边冒，注意，每一轮都是从最右边往左边比较</xhtml:p><xhtml:p>		//i=0,i=1,i=2,i=3  i&lt;5-1 --&gt;  i&lt;4 --&gt;  i&lt;=3</xhtml:p><xhtml:p>		for(int i=0; i&lt;arr.length-1; i++){//一共n-1轮</xhtml:p><xhtml:p>			//每一轮都要从最右边往左边比较</xhtml:p><xhtml:p>			/*</xhtml:p><xhtml:p>			 * 第一轮：比较n-1次，比较4次， i=0, j=4,3,2,1 ,j&gt;i</xhtml:p><xhtml:p>			 * 第二轮：比较3次，i=1, j=4,3,2 ,j&gt;i</xhtml:p><xhtml:p>			 * ....</xhtml:p><xhtml:p>			 */</xhtml:p><xhtml:p>			for(int j=arr.length-1; j&gt;i; j--){</xhtml:p><xhtml:p>				//相邻的元素比较，而且如果右边的比左边的小，需要交换</xhtml:p><xhtml:p>				if(arr[j] &lt; arr[j-1]){</xhtml:p><xhtml:p>					int temp = arr[j];</xhtml:p><xhtml:p>					arr[j] = arr[j-1];</xhtml:p><xhtml:p>					arr[j-1] = temp;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	</xhtml:p><xhtml:p>	//冒泡排序：从小到大</xhtml:p><xhtml:p>	//如果数组是5个元素</xhtml:p><xhtml:p>	public static void pubSort(int[] arr){</xhtml:p><xhtml:p>		//排序规则：每一轮通过相邻元素的比较，把小的往左边冒（或把大的往右边沉），每一轮都是把本轮的最小值冒出来（最大值沉下去）</xhtml:p><xhtml:p>		//经过n-1轮完成最终的排序</xhtml:p><xhtml:p>		//(1)方式一：把小的往左边冒，注意，每一轮都是从最右边往左边比较</xhtml:p><xhtml:p>		for(int i=1; i&lt;arr.length; i++){//一共n-1轮</xhtml:p><xhtml:p>			//每一轮都要从最右边往左边比较</xhtml:p><xhtml:p>			/*</xhtml:p><xhtml:p>			 * 第一轮：比较n-1次，比较4次， i=1, j=4,3,2,1 ,j&gt;=i</xhtml:p><xhtml:p>			 * 第二轮：比较3次，i=2, j=4,3,2 ,j&gt;=i</xhtml:p><xhtml:p>			 * ....</xhtml:p><xhtml:p>			 */</xhtml:p><xhtml:p>			for(int j=arr.length-1; j&gt;=i; j--){</xhtml:p><xhtml:p>				//相邻的元素比较，而且如果右边的比左边的小，需要交换</xhtml:p><xhtml:p>				if(arr[j] &lt; arr[j-1]){</xhtml:p><xhtml:p>					int temp = arr[j];</xhtml:p><xhtml:p>					arr[j] = arr[j-1];</xhtml:p><xhtml:p>					arr[j-1] = temp;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//假设数组5个元素&#13;
	public static void pubSort3(int[] arr){&#13;
		//方式二：把大的往右沉&#13;
		//每一轮从左边开始比较&#13;
		//比较的轮数依然是n-1轮&#13;
		for(int i=1; i&lt;arr.length; i++){&#13;
			//每一轮从左边开始比较&#13;
			/*&#13;
			 * 第一轮：i=1， 比较4次，j=0,1,2,3   ,j&lt;arr.length-i  j&lt;5-1 j&lt;4 &#13;
			 * 第二轮：i=2，比较3次，j=0,1,2      ,j&lt;arr.length-i  j&lt;5-2 j&lt;3&#13;
			 * ...&#13;
			 */&#13;
			for(int j=0; j&lt;arr.length-i; j++){&#13;
				//如果左边的元比右边的元素大，交换&#13;
				if(arr[j] &gt; arr[j+1]){&#13;
					int temp = arr[j];&#13;
					arr[j] = arr[j+1];&#13;
					arr[j+1] = temp;&#13;
				}&#13;
			}&#13;
		}&#13;
	}&#13;
	&#13;
	//假设数组5个元素&#13;
	public static void pubSort2(int[] arr){&#13;
		//排序规则：每一轮通过相邻元素的比较，把小的往左边冒（或把大的往右边沉），每一轮都是把本轮的最小值冒出来（最大值沉下去）&#13;
		//经过n-1轮完成最终的排序&#13;
		//(1)方式一：把小的往左边冒，注意，每一轮都是从最右边往左边比较&#13;
		//i=0,i=1,i=2,i=3  i&lt;5-1 --&gt;  i&lt;4 --&gt;  i&lt;=3&#13;
		for(int i=0; i&lt;arr.length-1; i++){//一共n-1轮&#13;
			//每一轮都要从最右边往左边比较&#13;
			/*&#13;
			 * 第一轮：比较n-1次，比较4次， i=0, j=4,3,2,1 ,j&gt;i&#13;
			 * 第二轮：比较3次，i=1, j=4,3,2 ,j&gt;i&#13;
			 * ....&#13;
			 */&#13;
			for(int j=arr.length-1; j&gt;i; j--){&#13;
				//相邻的元素比较，而且如果右边的比左边的小，需要交换&#13;
				if(arr[j] &lt; arr[j-1]){&#13;
					int temp = arr[j];&#13;
					arr[j] = arr[j-1];&#13;
					arr[j-1] = temp;&#13;
				}&#13;
			}&#13;
		}&#13;
	}&#13;
	&#13;
	//冒泡排序：从小到大&#13;
	//如果数组是5个元素&#13;
	public static void pubSort(int[] arr){&#13;
		//排序规则：每一轮通过相邻元素的比较，把小的往左边冒（或把大的往右边沉），每一轮都是把本轮的最小值冒出来（最大值沉下去）&#13;
		//经过n-1轮完成最终的排序&#13;
		//(1)方式一：把小的往左边冒，注意，每一轮都是从最右边往左边比较&#13;
		for(int i=1; i&lt;arr.length; i++){//一共n-1轮&#13;
			//每一轮都要从最右边往左边比较&#13;
			/*&#13;
			 * 第一轮：比较n-1次，比较4次， i=1, j=4,3,2,1 ,j&gt;=i&#13;
			 * 第二轮：比较3次，i=2, j=4,3,2 ,j&gt;=i&#13;
			 * ....&#13;
			 */&#13;
			for(int j=arr.length-1; j&gt;=i; j--){&#13;
				//相邻的元素比较，而且如果右边的比左边的小，需要交换&#13;
				if(arr[j] &lt; arr[j-1]){&#13;
					int temp = arr[j];&#13;
					arr[j] = arr[j-1];&#13;
					arr[j-1] = temp;&#13;
				}&#13;
			}&#13;
		}&#13;
	}</plain></notes></topic><topic id="05bs9vq3mf4ugfvon3m6nmcvvs" modified-by="" timestamp="1511144958357"><title>直接选择排序</title><notes><html><xhtml:p>	//直接选择排序</xhtml:p><xhtml:p>	//基本原理：将待排序的元素分为已排序（初始为空）和未排序两组，依次将未排序的元素中值最小的元素放入已排序的组中。</xhtml:p><xhtml:p>	//[3,2,1,5,4]  从小到大排序</xhtml:p><xhtml:p>	/*</xhtml:p><xhtml:p>	 * 第一次：所有元素都属于未排序   把未排序的元素中的最小值找出来    arr[2] = 1 ，放入已排序组中     和第一个元素交换</xhtml:p><xhtml:p>	 * 		[1,2,3,5,4]</xhtml:p><xhtml:p>	 * 第二次：已排序的是[1]，未排序的是[2,3,5,4]，把未排序元素中的最小值找出  arr[1]=2，放入已排序组中  </xhtml:p><xhtml:p>	 * 		【1,2】，【3,5,4】</xhtml:p><xhtml:p>	 * ...</xhtml:p><xhtml:p>	 * </xhtml:p><xhtml:p>	 */</xhtml:p><xhtml:p>	//假设5个元素</xhtml:p><xhtml:p>	public static void selectSort(int[] arr){</xhtml:p><xhtml:p>		//次数</xhtml:p><xhtml:p>		for(int i=0; i&lt;arr.length-1; i++){</xhtml:p><xhtml:p>			//第一次，找最小值</xhtml:p><xhtml:p>			//假设每一轮的未排序元素的第一个最小</xhtml:p><xhtml:p>			int index = i;</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//找出本轮最小值</xhtml:p><xhtml:p>			/*</xhtml:p><xhtml:p>			 * int i=0 ,从哪些元素中找最小值  [0]~[4]   j=1,2,3,4</xhtml:p><xhtml:p>			 * int i=1，从哪些元素中找最小值[1]~[4]    j=2,3,4</xhtml:p><xhtml:p>			 * ...</xhtml:p><xhtml:p>			 */</xhtml:p><xhtml:p>			for(int j=i+1; j&lt;arr.length; j++){</xhtml:p><xhtml:p>				if(arr[index] &gt; arr[j]){</xhtml:p><xhtml:p>					index = j;</xhtml:p><xhtml:p>				}</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>			//找出arr[index]值最小，下标是index</xhtml:p><xhtml:p>			//arr[i] 和 arr[index]交换</xhtml:p><xhtml:p>			if(i!=index){</xhtml:p><xhtml:p>				int temp = arr[i];</xhtml:p><xhtml:p>				arr[i] = arr[index];</xhtml:p><xhtml:p>				arr[index] = temp;</xhtml:p><xhtml:p>			}</xhtml:p><xhtml:p>			</xhtml:p><xhtml:p>		}</xhtml:p><xhtml:p>	}</xhtml:p></html><plain>	//直接选择排序&#13;
	//基本原理：将待排序的元素分为已排序（初始为空）和未排序两组，依次将未排序的元素中值最小的元素放入已排序的组中。&#13;
	//[3,2,1,5,4]  从小到大排序&#13;
	/*&#13;
	 * 第一次：所有元素都属于未排序   把未排序的元素中的最小值找出来    arr[2] = 1 ，放入已排序组中     和第一个元素交换&#13;
	 * 		[1,2,3,5,4]&#13;
	 * 第二次：已排序的是[1]，未排序的是[2,3,5,4]，把未排序元素中的最小值找出  arr[1]=2，放入已排序组中  &#13;
	 * 		【1,2】，【3,5,4】&#13;
	 * ...&#13;
	 * &#13;
	 */&#13;
	//假设5个元素&#13;
	public static void selectSort(int[] arr){&#13;
		//次数&#13;
		for(int i=0; i&lt;arr.length-1; i++){&#13;
			//第一次，找最小值&#13;
			//假设每一轮的未排序元素的第一个最小&#13;
			int index = i;&#13;
			&#13;
			//找出本轮最小值&#13;
			/*&#13;
			 * int i=0 ,从哪些元素中找最小值  [0]~[4]   j=1,2,3,4&#13;
			 * int i=1，从哪些元素中找最小值[1]~[4]    j=2,3,4&#13;
			 * ...&#13;
			 */&#13;
			for(int j=i+1; j&lt;arr.length; j++){&#13;
				if(arr[index] &gt; arr[j]){&#13;
					index = j;&#13;
				}&#13;
			}&#13;
			&#13;
			//找出arr[index]值最小，下标是index&#13;
			//arr[i] 和 arr[index]交换&#13;
			if(i!=index){&#13;
				int temp = arr[i];&#13;
				arr[i] = arr[index];&#13;
				arr[index] = temp;&#13;
			}&#13;
			&#13;
		}&#13;
	}</plain></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>画布 6</title></sheet></xmap-revision-content>